# Quickstart

[wand_stars **Introducing Unfold Studio** - Supercharge your Unfold admin with premium features arrow_forward](https://unfoldadmin.com/studio/)

[**unfold**](https://unfoldadmin.com/)

[Studio](https://unfoldadmin.com/studio/)[Consulting](https://unfoldadmin.com/consulting/)[Docs](https://unfoldadmin.com/docs/)

[Sign in](https://unfoldadmin.com/accounts/login/)[Sign up](https://unfoldadmin.com/accounts/signup/)

1. **Installation**
    1. [Quickstart](https://unfoldadmin.com/docs/installation/quickstart/)
    2. [User & group models](https://unfoldadmin.com/docs/installation/auth/)
2. **Configuration**
    1. [Settings options](https://unfoldadmin.com/docs/configuration/settings/)
    2. [Site dropdown](https://unfoldadmin.com/docs/configuration/site-dropdown/)
    3. [ModelAdmin options](https://unfoldadmin.com/docs/configuration/modeladmin/)
    4. [Conditional fields](https://unfoldadmin.com/docs/configuration/conditional-fields/)
    5. [Paginator](https://unfoldadmin.com/docs/configuration/paginator/)
    6. [Crispy Forms](https://unfoldadmin.com/docs/configuration/crispy-forms/)
    7. [Sections (Expandable rows)](https://unfoldadmin.com/docs/configuration/sections/)
    8. [Custom pages](https://unfoldadmin.com/docs/configuration/custom-pages/)
    9. [Dashboard](https://unfoldadmin.com/docs/configuration/dashboard/)
    10. [Custom sites](https://unfoldadmin.com/docs/configuration/custom-sites/)
    11. [Multi-language](https://unfoldadmin.com/docs/configuration/multi-language/)
3. **Filters**
    1. [Introduction to filters](https://unfoldadmin.com/docs/filters/introduction/)
    2. [Text filter](https://unfoldadmin.com/docs/filters/text/)
    3. [Datetime filter](https://unfoldadmin.com/docs/filters/datetime/)
    4. [Dropdown filter](https://unfoldadmin.com/docs/filters/dropdown/)
    5. [Numeric filter](https://unfoldadmin.com/docs/filters/numeric/)
    6. [Horizontal layout filter](https://unfoldadmin.com/docs/filters/horizontal/)
    7. [Autocomplete filter](https://unfoldadmin.com/docs/filters/autocomplete/)
    8. [Checkbox and radio filters](https://unfoldadmin.com/docs/filters/checkbox-radio/)
4. **Actions**
    1. [Introduction to actions](https://unfoldadmin.com/docs/actions/introduction/)
    2. [Changelist actions](https://unfoldadmin.com/docs/actions/changelist/)
    3. [Changelist row actions](https://unfoldadmin.com/docs/actions/changelist-row/)
    4. [Changeform actions](https://unfoldadmin.com/docs/actions/changeform/)
    5. [Changeform submitline actions](https://unfoldadmin.com/docs/actions/changeform-submitline/)
    6. [Dropdown action](https://unfoldadmin.com/docs/actions/dropdown-actions/)
    7. [Action with form example](https://unfoldadmin.com/docs/actions/action-form-example/)
5. **Tabs**
    1. [Changelist tabs](https://unfoldadmin.com/docs/tabs/changelist/)
    2. [Changeform tabs](https://unfoldadmin.com/docs/tabs/changeform/)
    3. [Fieldsets tabs](https://unfoldadmin.com/docs/tabs/fieldsets/)
    4. [Inlines tabs](https://unfoldadmin.com/docs/tabs/inline/)
    5. [Dynamic tabs](https://unfoldadmin.com/docs/tabs/dynamic/)
6. **Widgets**
    1. [ArrayWidget](https://unfoldadmin.com/docs/widgets/array/)
    2. [WysiwygWidget](https://unfoldadmin.com/docs/widgets/wysiwyg/)
7. **Inlines**
    1. [Introduction to inlines](https://unfoldadmin.com/docs/inlines/introduction/)
    2. [Inline options](https://unfoldadmin.com/docs/inlines/options/)
    3. [Nonrelated inlines](https://unfoldadmin.com/docs/inlines/nonrelated/)
    4. [Sortable inlines](https://unfoldadmin.com/docs/inlines/sortable/)
    5. [Paginated inlines](https://unfoldadmin.com/docs/inlines/paginated/)
8. **Fields**
    1. [JsonField](https://unfoldadmin.com/docs/fields/json/)
9. **Integrations**
    1. [django-celery-beat](https://unfoldadmin.com/docs/integrations/django-celery-beat/)
    2. [django-money](https://unfoldadmin.com/docs/integrations/django-money/)
    3. [django-import-export](https://unfoldadmin.com/docs/integrations/django-import-export/)
    4. [django-simple-history](https://unfoldadmin.com/docs/integrations/django-simple-history/)
    5. [django-guardian](https://unfoldadmin.com/docs/integrations/django-guardian/)
    6. [django-modeltranslation](https://unfoldadmin.com/docs/integrations/django-modeltranslation/)
10. **Components**
    1. [Introduction to components](https://unfoldadmin.com/docs/components/introduction/)
    2. [Component class](https://unfoldadmin.com/docs/components/component-class/)
    3. [Component - Cohort](https://unfoldadmin.com/docs/components/cohort/)
    4. [Component - Tracker](https://unfoldadmin.com/docs/components/tracker/)
    5. [Component - Table](https://unfoldadmin.com/docs/components/table/)
    6. [Component - Button](https://unfoldadmin.com/docs/components/button/)
11. **Decorators**
    1. [Display](https://unfoldadmin.com/docs/decorators/display/)
    2. [Action](https://unfoldadmin.com/docs/decorators/action/)
12. **Styles & scripts**
    1. [Loading styles and scripts](https://unfoldadmin.com/docs/styles-scripts/loading-files/)
    2. [Customizing Tailwind stylesheet](https://unfoldadmin.com/docs/styles-scripts/customizing-tailwind/)
13. **Development**
    1. [Poetry dependecy path](https://unfoldadmin.com/docs/development/poetry-dependency/)
    2. [VS Code devcontainers](https://unfoldadmin.com/docs/development/devcontainer/)

1. 1.
    
    ### **Installation**
    
    1. 1. [Quickstart](https://unfoldadmin.com/docs/installation/quickstart/)
    2. 2. [User & group models](https://unfoldadmin.com/docs/installation/auth/)
2. 
3. 
4. 2.
    
    ### **Configuration**
    
    1. 1. [Settings options](https://unfoldadmin.com/docs/configuration/settings/)
    2. 2. [Site dropdown](https://unfoldadmin.com/docs/configuration/site-dropdown/)
    3. 3. [ModelAdmin options](https://unfoldadmin.com/docs/configuration/modeladmin/)
    4. 4. [Conditional fields](https://unfoldadmin.com/docs/configuration/conditional-fields/)
    5. 5. [Paginator](https://unfoldadmin.com/docs/configuration/paginator/)
    6. 6. [Crispy Forms](https://unfoldadmin.com/docs/configuration/crispy-forms/)
    7. 7. [Sections (Expandable rows)](https://unfoldadmin.com/docs/configuration/sections/)
    8. 8. [Custom pages](https://unfoldadmin.com/docs/configuration/custom-pages/)
    9. 9. [Dashboard](https://unfoldadmin.com/docs/configuration/dashboard/)
    10. 10. [Custom sites](https://unfoldadmin.com/docs/configuration/custom-sites/)
    11. 11. [Multi-language](https://unfoldadmin.com/docs/configuration/multi-language/)
5. 
6. 
7. 
8. 
9. 
10. 
11. 
12. 
13. 
14. 
15. 
16. 3.
    
    ### **Filters**
    
    1. 1. [Introduction to filters](https://unfoldadmin.com/docs/filters/introduction/)
    2. 2. [Text filter](https://unfoldadmin.com/docs/filters/text/)
    3. 3. [Datetime filter](https://unfoldadmin.com/docs/filters/datetime/)
    4. 4. [Dropdown filter](https://unfoldadmin.com/docs/filters/dropdown/)
    5. 5. [Numeric filter](https://unfoldadmin.com/docs/filters/numeric/)
    6. 6. [Horizontal layout filter](https://unfoldadmin.com/docs/filters/horizontal/)
    7. 7. [Autocomplete filter](https://unfoldadmin.com/docs/filters/autocomplete/)
    8. 8. [Checkbox and radio filters](https://unfoldadmin.com/docs/filters/checkbox-radio/)
17. 
18. 
19. 
20. 
21. 
22. 
23. 
24. 
25. 4.
    
    ### **Actions**
    
    1. 1. [Introduction to actions](https://unfoldadmin.com/docs/actions/introduction/)
    2. 2. [Changelist actions](https://unfoldadmin.com/docs/actions/changelist/)
    3. 3. [Changelist row actions](https://unfoldadmin.com/docs/actions/changelist-row/)
    4. 4. [Changeform actions](https://unfoldadmin.com/docs/actions/changeform/)
    5. 5. [Changeform submitline actions](https://unfoldadmin.com/docs/actions/changeform-submitline/)
    6. 6. [Dropdown action](https://unfoldadmin.com/docs/actions/dropdown-actions/)
    7. 7. [Action with form example](https://unfoldadmin.com/docs/actions/action-form-example/)
26. 
27. 
28. 
29. 
30. 
31. 
32. 
33. 5.
    
    ### **Tabs**
    
    1. 1. [Changelist tabs](https://unfoldadmin.com/docs/tabs/changelist/)
    2. 2. [Changeform tabs](https://unfoldadmin.com/docs/tabs/changeform/)
    3. 3. [Fieldsets tabs](https://unfoldadmin.com/docs/tabs/fieldsets/)
    4. 4. [Inlines tabs](https://unfoldadmin.com/docs/tabs/inline/)
    5. 5. [Dynamic tabs](https://unfoldadmin.com/docs/tabs/dynamic/)
34. 
35. 
36. 
37. 
38. 
39. 6.
    
    ### **Widgets**
    
    1. 1. [ArrayWidget](https://unfoldadmin.com/docs/widgets/array/)
    2. 2. [WysiwygWidget](https://unfoldadmin.com/docs/widgets/wysiwyg/)
40. 
41. 
42. 7.
    
    ### **Inlines**
    
    1. 1. [Introduction to inlines](https://unfoldadmin.com/docs/inlines/introduction/)
    2. 2. [Inline options](https://unfoldadmin.com/docs/inlines/options/)
    3. 3. [Nonrelated inlines](https://unfoldadmin.com/docs/inlines/nonrelated/)
    4. 4. [Sortable inlines](https://unfoldadmin.com/docs/inlines/sortable/)
    5. 5. [Paginated inlines](https://unfoldadmin.com/docs/inlines/paginated/)
43. 
44. 
45. 
46. 
47. 
48. 8.
    
    ### **Fields**
    
    1. 1. [JsonField](https://unfoldadmin.com/docs/fields/json/)
49. 
50. 9.
    
    ### **Integrations**
    
    1. 1. [django-celery-beat](https://unfoldadmin.com/docs/integrations/django-celery-beat/)
    2. 2. [django-money](https://unfoldadmin.com/docs/integrations/django-money/)
    3. 3. [django-import-export](https://unfoldadmin.com/docs/integrations/django-import-export/)
    4. 4. [django-simple-history](https://unfoldadmin.com/docs/integrations/django-simple-history/)
    5. 5. [django-guardian](https://unfoldadmin.com/docs/integrations/django-guardian/)
    6. 6. [django-modeltranslation](https://unfoldadmin.com/docs/integrations/django-modeltranslation/)
51. 
52. 
53. 
54. 
55. 
56. 
57. 10.
    
    ### **Components**
    
    1. 1. [Introduction to components](https://unfoldadmin.com/docs/components/introduction/)
    2. 2. [Component class](https://unfoldadmin.com/docs/components/component-class/)
    3. 3. [Component - Cohort](https://unfoldadmin.com/docs/components/cohort/)
    4. 4. [Component - Tracker](https://unfoldadmin.com/docs/components/tracker/)
    5. 5. [Component - Table](https://unfoldadmin.com/docs/components/table/)
    6. 6. [Component - Button](https://unfoldadmin.com/docs/components/button/)
58. 
59. 
60. 
61. 
62. 
63. 
64. 11.
    
    ### **Decorators**
    
    1. 1. [Display](https://unfoldadmin.com/docs/decorators/display/)
    2. 2. [Action](https://unfoldadmin.com/docs/decorators/action/)
65. 
66. 
67. 12.
    
    ### **Styles & scripts**
    
    1. 1. [Loading styles and scripts](https://unfoldadmin.com/docs/styles-scripts/loading-files/)
    2. 2. [Customizing Tailwind stylesheet](https://unfoldadmin.com/docs/styles-scripts/customizing-tailwind/)
68. 
69. 
70. 13.
    
    ### **Development**
    
    1. 1. [Poetry dependecy path](https://unfoldadmin.com/docs/development/poetry-dependency/)
    2. 2. [VS Code devcontainers](https://unfoldadmin.com/docs/development/devcontainer/)
71. 
72. 

1. Documentation 
2. Installation 
3. **Quickstart**

1. 1. Documentation
2. 2. Installation
3. 3. **Quickstart**

# **Quickstart**

The installation process is straightforward. After installing the package, you only need to add the Unfold application to the beginning of your **INSTALLED_APPS** setting. The default admin configuration in urls.py can remain unchanged.

```
# settings.pyINSTALLED_APPS = [    "unfold",  # before django.contrib.admin    "unfold.contrib.filters",  # optional, if special filters are needed    "unfold.contrib.forms",  # optional, if special form elements are needed    "unfold.contrib.inlines",  # optional, if special inlines are needed    "unfold.contrib.import_export",  # optional, if django-import-export package is used    "unfold.contrib.guardian",  # optional, if django-guardian package is used    "unfold.contrib.simple_history",  # optional, if django-simple-history package is used    "django.contrib.admin",  # required]
```

To install Django Unfold in your project, you can use any of the popular Python package managers. Below are the installation commands for **`pip`**, **`uv`**, and **`poetry`**. Execute the appropriate command in your terminal based on your preferred package manager:

```
pip install django-unfolduv add django-unfoldpoetry add django-unfold
```

Below is an example of the minimal URL configuration needed to integrate Unfold into your Django project:

```
# urls.pyfrom django.contrib import adminfrom django.urls import pathurlpatterns = [    path("admin/", admin.site.urls),    # Other URL paths]
```

# **ModelAdmin inheritance**

After installation, your admin classes must inherit from **`unfold.admin.ModelAdmin`** instead of the default **`django.contrib.admin.ModelAdmin`**. Using the default admin class will result in unstyled forms and missing Unfold functionality.

```
# admin.pyfrom django.contrib import adminfrom unfold.admin import ModelAdmin@admin.register(MyModel)class CustomAdminClass(ModelAdmin):    pass
```

© 2023 - 2025 Created by unfoldadmin.com. All rights reserved.

1. Documentation 
2. Installation 
3. **User & group models**

1. 1. Documentation
2. 2. Installation
3. 3. **User & group models**

# **User & group models**

When **`django.contrib.auth`** is included in **`INSTALLED_APPS`**, Django automatically provides user and group models in the admin interface. While these models will function correctly, they will appear unstyled since they don't inherit from **`unfold.admin.ModelAdmin`**.

To resolve this, you need to unregister the default admin classes and re-register them using **`unfold.admin.ModelAdmin`** as shown in the example below. You'll also need to override the default user forms (from the **`UserAdmin`** class) that Django admin loads by default. The overridden forms will have the proper Unfold styling applied.

```
# admin.pyfrom django.contrib import adminfrom django.contrib.auth.admin import UserAdmin as BaseUserAdminfrom django.contrib.auth.admin import GroupAdmin as BaseGroupAdminfrom django.contrib.auth.models import User, Groupfrom unfold.forms import AdminPasswordChangeForm, UserChangeForm, UserCreationFormfrom unfold.admin import ModelAdminadmin.site.unregister(User)admin.site.unregister(Group)@admin.register(User)class UserAdmin(BaseUserAdmin,ModelAdmin):    # Forms loaded from `unfold.forms`    form = UserChangeForm    add_form = UserCreationForm    change_password_form = AdminPasswordChangeForm@admin.register(Group)class GroupAdmin(BaseGroupAdmin,ModelAdmin):    pass
```

# Configuration

# **Settings options**

The **`UNFOLD`** dictionary provides a comprehensive set of configuration options for customizing the Django admin interface. While the admin interface works perfectly well with default settings and requires no additional configuration, you have the flexibility to customize various aspects of its behavior and appearance. Below you'll find a complete list of all available configuration options that can be defined in your settings file.

```
# settings.pyfrom django.templatetags.static import staticfrom django.urls import reverse_lazyfrom django.utils.translation import gettext_lazy as _UNFOLD = {    "SITE_TITLE": "Custom suffix in <title> tag",    "SITE_HEADER": "Appears in sidebar at the top",    "SITE_SUBHEADER": "Appears under SITE_HEADER",    "SITE_DROPDOWN": [        {            "icon": "diamond",            "title": _("My site"),            "link": "https://example.com",        },        # ...    ],    "SITE_URL": "/",    # "SITE_ICON": lambda request: static("icon.svg"),  # both modes, optimise for 32px height    "SITE_ICON": {        "light": lambda request: static("icon-light.svg"),  # light mode        "dark": lambda request: static("icon-dark.svg"),  # dark mode    },    # "SITE_LOGO": lambda request: static("logo.svg"),  # both modes, optimise for 32px height    "SITE_LOGO": {        "light": lambda request: static("logo-light.svg"),  # light mode        "dark": lambda request: static("logo-dark.svg"),  # dark mode    },    "SITE_SYMBOL": "speed",  # symbol from icon set    "SITE_FAVICONS": [        {            "rel": "icon",            "sizes": "32x32",            "type": "image/svg+xml",            "href": lambda request: static("favicon.svg"),        },    ],    "SHOW_HISTORY": True, # show/hide "History" button, default: True    "SHOW_VIEW_ON_SITE": True, # show/hide "View on site" button, default: True    "SHOW_BACK_BUTTON": False, # show/hide "Back" button on changeform in header, default: False    "ENVIRONMENT": "sample_app.environment_callback", # environment name in header    "ENVIRONMENT_TITLE_PREFIX": "sample_app.environment_title_prefix_callback", # environment name prefix in title tag    "DASHBOARD_CALLBACK": "sample_app.dashboard_callback",    "THEME": "dark", # Force theme: "dark" or "light". Will disable theme switcher    "LOGIN": {        "image": lambda request: static("sample/login-bg.jpg"),        "redirect_after": lambda request: reverse_lazy("admin:APP_MODEL_changelist"),    },    "STYLES": [        lambda request: static("css/style.css"),    ],    "SCRIPTS": [        lambda request: static("js/script.js"),    ],    "BORDER_RADIUS": "6px",    "COLORS": {        "base": {            "50": "249, 250, 251",            "100": "243, 244, 246",            "200": "229, 231, 235",            "300": "209, 213, 219",            "400": "156, 163, 175",            "500": "107, 114, 128",            "600": "75, 85, 99",            "700": "55, 65, 81",            "800": "31, 41, 55",            "900": "17, 24, 39",            "950": "3, 7, 18",        },        "primary": {            "50": "250, 245, 255",            "100": "243, 232, 255",            "200": "233, 213, 255",            "300": "216, 180, 254",            "400": "192, 132, 252",            "500": "168, 85, 247",            "600": "147, 51, 234",            "700": "126, 34, 206",            "800": "107, 33, 168",            "900": "88, 28, 135",            "950": "59, 7, 100",        },        "font": {            "subtle-light": "var(--color-base-500)",  # text-base-500            "subtle-dark": "var(--color-base-400)",  # text-base-400            "default-light": "var(--color-base-600)",  # text-base-600            "default-dark": "var(--color-base-300)",  # text-base-300            "important-light": "var(--color-base-900)",  # text-base-900            "important-dark": "var(--color-base-100)",  # text-base-100        },    },    "EXTENSIONS": {        "modeltranslation": {            "flags": {                "en": "🇬🇧",                "fr": "🇫🇷",                "nl": "🇧🇪",            },        },    },    "SIDEBAR": {        "show_search": False,  # Search in applications and models names        "show_all_applications": False,  # Dropdown with all applications and models        "navigation": [            {                "title": _("Navigation"),                "separator": True,  # Top border                "collapsible": True,  # Collapsible group of links                "items": [                    {                        "title": _("Dashboard"),                        "icon": "dashboard",  # Supported icon set: https://fonts.google.com/icons                        "link": reverse_lazy("admin:index"),                        "badge": "sample_app.badge_callback",                        "permission": lambda request: request.user.is_superuser,                    },                    {                        "title": _("Users"),                        "icon": "people",                        "link": reverse_lazy("admin:auth_user_changelist"),                    },                ],            },        ],    },    "TABS": [        {            "models": [                "app_label.model_name_in_lowercase",            ],            "items": [                {                    "title": _("Your custom title"),                    "link": reverse_lazy("admin:app_label_model_name_changelist"),                    "permission": "sample_app.permission_callback",                },            ],        },    ],}def dashboard_callback(request, context):    """    Callback to prepare custom variables for index template which is used as dashboard    template. It can be overridden in application by creating custom admin/index.html.    """    context.update(        {            "sample": "example",  # this will be injected into templates/admin/index.html        }    )    return contextdef environment_callback(request):    """    Callback has to return a list of two values represeting text value and the color    type of the label displayed in top right corner.    """    return ["Production", "danger"] # info, danger, warning, successdef badge_callback(request):    return 3def permission_callback(request):    return request.user.has_perm("sample_app.change_model")
```

# **Site dropdown**

Django Unfold offers a flexible way to enhance your admin interface by adding a dropdown navigation menu in the sidebar. This feature is activated when clicking on the site header and can be configured using the **`SITE_DROPDOWN`** option within the **`UNFOLD`** configuration dictionary. When you enable this feature by setting the option, a dropdown icon will automatically appear next to the site header, providing a visual indication that it's interactive and can be clicked to reveal additional navigation options.

![Unfold site dropdown](https://unfoldadmin.com/static/docs/configuration/unfold-site-dropdown.webp)

You can explore this feature in action by visiting our live demo at https://demo.unfoldadmin.com. Simply navigate to the top left corner of the interface and click on the site title - you'll see the dropdown menu elegantly appear, showcasing the navigation options. This interactive demo provides a hands-on way to understand how the dropdown navigation enhances the admin interface's usability.

```
# settings.pyfrom django.urls import reverse_lazyfrom django.utils.translation import gettext_lazy as _UNFOLD = {    "SITE_DROPDOWN": [        {            "icon": "diamond",            "title": _("My site"),            "link": "https://example.com",        },        {            "icon": "diamond",            "title": _("My site"),            "link": reverse_lazy("admin:index"),        },    ]}
```

# **ModelAdmin options**

Each admin class has to inherit from **`unfold.admin.ModelAdmin`** to get access to all available options. By using **`django.contrib.admin.ModelAdmin`** the options are not going to work and admin pages will be missing styling and features provided by Unfold.

```
# admin.pyfrom django import modelsfrom django.contrib import adminfrom django.contrib.postgres.fields import ArrayFieldfrom django.db import modelsfrom unfold.admin import ModelAdminfrom unfold.contrib.forms.widgets import ArrayWidget, WysiwygWidget@admin.register(MyModel)class CustomAdminClass(ModelAdmin):    # Display fields in changeform in compressed mode    compressed_fields = True  # Default: False    # Warn before leaving unsaved changes in changeform    warn_unsaved_form = True  # Default: False    # Preprocess content of readonly fields before render    readonly_preprocess_fields = {        "model_field_name": "html.unescape",        "other_field_name": lambda content: content.strip(),    }    # Display submit button in filters    list_filter_submit = False    # Display changelist in fullwidth    list_fullwidth = False    # Set to False, to enable filter as "sidebar"    list_filter_sheet = True    # Position horizontal scrollbar in changelist at the top    list_horizontal_scrollbar_top = False    # Dsable select all action in changelist    list_disable_select_all = False    # Custom actions    actions_list = []  # Displayed above the results list    actions_row = []  # Displayed in a table row in results list    actions_detail = []  # Displayed at the top of for in object detail    actions_submit_line = []  # Displayed near save in object detail    # Changeform templates (located inside the form)    change_form_before_template = "some/template.html"    change_form_after_template = "some/template.html"    # Located outside of the form    change_form_outer_before_template = "some/template.html"    change_form_outer_after_template = "some/template.html"    # Display cancel button in submit line in changeform    change_form_show_cancel_button = True # show/hide cancel button in changeform, default: False    formfield_overrides = {        models.TextField: {            "widget": WysiwygWidget,        },        ArrayField: {            "widget": ArrayWidget,        }    }
```

# **Settings options**

The **`UNFOLD`** dictionary provides a comprehensive set of configuration options for customizing the Django admin interface. While the admin interface works perfectly well with default settings and requires no additional configuration, you have the flexibility to customize various aspects of its behavior and appearance. Below you'll find a complete list of all available configuration options that can be defined in your settings file.

```
# settings.pyfrom django.templatetags.static import staticfrom django.urls import reverse_lazyfrom django.utils.translation import gettext_lazy as _UNFOLD = {    "SITE_TITLE": "Custom suffix in <title> tag",    "SITE_HEADER": "Appears in sidebar at the top",    "SITE_SUBHEADER": "Appears under SITE_HEADER",    "SITE_DROPDOWN": [        {            "icon": "diamond",            "title": _("My site"),            "link": "https://example.com",        },        # ...    ],    "SITE_URL": "/",    # "SITE_ICON": lambda request: static("icon.svg"),  # both modes, optimise for 32px height    "SITE_ICON": {        "light": lambda request: static("icon-light.svg"),  # light mode        "dark": lambda request: static("icon-dark.svg"),  # dark mode    },    # "SITE_LOGO": lambda request: static("logo.svg"),  # both modes, optimise for 32px height    "SITE_LOGO": {        "light": lambda request: static("logo-light.svg"),  # light mode        "dark": lambda request: static("logo-dark.svg"),  # dark mode    },    "SITE_SYMBOL": "speed",  # symbol from icon set    "SITE_FAVICONS": [        {            "rel": "icon",            "sizes": "32x32",            "type": "image/svg+xml",            "href": lambda request: static("favicon.svg"),        },    ],    "SHOW_HISTORY": True, # show/hide "History" button, default: True    "SHOW_VIEW_ON_SITE": True, # show/hide "View on site" button, default: True    "SHOW_BACK_BUTTON": False, # show/hide "Back" button on changeform in header, default: False    "ENVIRONMENT": "sample_app.environment_callback", # environment name in header    "ENVIRONMENT_TITLE_PREFIX": "sample_app.environment_title_prefix_callback", # environment name prefix in title tag    "DASHBOARD_CALLBACK": "sample_app.dashboard_callback",    "THEME": "dark", # Force theme: "dark" or "light". Will disable theme switcher    "LOGIN": {        "image": lambda request: static("sample/login-bg.jpg"),        "redirect_after": lambda request: reverse_lazy("admin:APP_MODEL_changelist"),    },    "STYLES": [        lambda request: static("css/style.css"),    ],    "SCRIPTS": [        lambda request: static("js/script.js"),    ],    "BORDER_RADIUS": "6px",    "COLORS": {        "base": {            "50": "249, 250, 251",            "100": "243, 244, 246",            "200": "229, 231, 235",            "300": "209, 213, 219",            "400": "156, 163, 175",            "500": "107, 114, 128",            "600": "75, 85, 99",            "700": "55, 65, 81",            "800": "31, 41, 55",            "900": "17, 24, 39",            "950": "3, 7, 18",        },        "primary": {            "50": "250, 245, 255",            "100": "243, 232, 255",            "200": "233, 213, 255",            "300": "216, 180, 254",            "400": "192, 132, 252",            "500": "168, 85, 247",            "600": "147, 51, 234",            "700": "126, 34, 206",            "800": "107, 33, 168",            "900": "88, 28, 135",            "950": "59, 7, 100",        },        "font": {            "subtle-light": "var(--color-base-500)",  # text-base-500            "subtle-dark": "var(--color-base-400)",  # text-base-400            "default-light": "var(--color-base-600)",  # text-base-600            "default-dark": "var(--color-base-300)",  # text-base-300            "important-light": "var(--color-base-900)",  # text-base-900            "important-dark": "var(--color-base-100)",  # text-base-100        },    },    "EXTENSIONS": {        "modeltranslation": {            "flags": {                "en": "🇬🇧",                "fr": "🇫🇷",                "nl": "🇧🇪",            },        },    },    "SIDEBAR": {        "show_search": False,  # Search in applications and models names        "show_all_applications": False,  # Dropdown with all applications and models        "navigation": [            {                "title": _("Navigation"),                "separator": True,  # Top border                "collapsible": True,  # Collapsible group of links                "items": [                    {                        "title": _("Dashboard"),                        "icon": "dashboard",  # Supported icon set: https://fonts.google.com/icons                        "link": reverse_lazy("admin:index"),                        "badge": "sample_app.badge_callback",                        "permission": lambda request: request.user.is_superuser,                    },                    {                        "title": _("Users"),                        "icon": "people",                        "link": reverse_lazy("admin:auth_user_changelist"),                    },                ],            },        ],    },    "TABS": [        {            "models": [                "app_label.model_name_in_lowercase",            ],            "items": [                {                    "title": _("Your custom title"),                    "link": reverse_lazy("admin:app_label_model_name_changelist"),                    "permission": "sample_app.permission_callback",                },            ],        },    ],}def dashboard_callback(request, context):    """    Callback to prepare custom variables for index template which is used as dashboard    template. It can be overridden in application by creating custom admin/index.html.    """    context.update(        {            "sample": "example",  # this will be injected into templates/admin/index.html        }    )    return contextdef environment_callback(request):    """    Callback has to return a list of two values represeting text value and the color    type of the label displayed in top right corner.    """    return ["Production", "danger"] # info, danger, warning, successdef badge_callback(request):    return 3def permission_callback(request):    return request.user.has_perm("sample_app.change_model")
```

### Site Dropdown

# **Site dropdown**

Django Unfold offers a flexible way to enhance your admin interface by adding a dropdown navigation menu in the sidebar. This feature is activated when clicking on the site header and can be configured using the **`SITE_DROPDOWN`** option within the **`UNFOLD`** configuration dictionary. When you enable this feature by setting the option, a dropdown icon will automatically appear next to the site header, providing a visual indication that it's interactive and can be clicked to reveal additional navigation options.

![Unfold site dropdown](https://unfoldadmin.com/static/docs/configuration/unfold-site-dropdown.webp)

You can explore this feature in action by visiting our live demo at https://demo.unfoldadmin.com. Simply navigate to the top left corner of the interface and click on the site title - you'll see the dropdown menu elegantly appear, showcasing the navigation options. This interactive demo provides a hands-on way to understand how the dropdown navigation enhances the admin interface's usability.

```
# settings.pyfrom django.urls import reverse_lazyfrom django.utils.translation import gettext_lazy as _UNFOLD = {    "SITE_DROPDOWN": [        {            "icon": "diamond",            "title": _("My site"),            "link": "https://example.com",        },        {            "icon": "diamond",            "title": _("My site"),            "link": reverse_lazy("admin:index"),        },    ]}
```

# **ModelAdmin options**

Each admin class has to inherit from **`unfold.admin.ModelAdmin`** to get access to all available options. By using **`django.contrib.admin.ModelAdmin`** the options are not going to work and admin pages will be missing styling and features provided by Unfold.

```
# admin.pyfrom django import modelsfrom django.contrib import adminfrom django.contrib.postgres.fields import ArrayFieldfrom django.db import modelsfrom unfold.admin import ModelAdminfrom unfold.contrib.forms.widgets import ArrayWidget, WysiwygWidget@admin.register(MyModel)class CustomAdminClass(ModelAdmin):    # Display fields in changeform in compressed mode    compressed_fields = True  # Default: False    # Warn before leaving unsaved changes in changeform    warn_unsaved_form = True  # Default: False    # Preprocess content of readonly fields before render    readonly_preprocess_fields = {        "model_field_name": "html.unescape",        "other_field_name": lambda content: content.strip(),    }    # Display submit button in filters    list_filter_submit = False    # Display changelist in fullwidth    list_fullwidth = False    # Set to False, to enable filter as "sidebar"    list_filter_sheet = True    # Position horizontal scrollbar in changelist at the top    list_horizontal_scrollbar_top = False    # Dsable select all action in changelist    list_disable_select_all = False    # Custom actions    actions_list = []  # Displayed above the results list    actions_row = []  # Displayed in a table row in results list    actions_detail = []  # Displayed at the top of for in object detail    actions_submit_line = []  # Displayed near save in object detail    # Changeform templates (located inside the form)    change_form_before_template = "some/template.html"    change_form_after_template = "some/template.html"    # Located outside of the form    change_form_outer_before_template = "some/template.html"    change_form_outer_after_template = "some/template.html"    # Display cancel button in submit line in changeform    change_form_show_cancel_button = True # show/hide cancel button in changeform, default: False    formfield_overrides = {        models.TextField: {            "widget": WysiwygWidget,        },        ArrayField: {            "widget": ArrayWidget,        }    }
```

# **Conditional fields**

Django Unfold offers a powerful feature for creating dynamic forms through conditional fields. This functionality allows you to control the visibility of specific form fields based on the values of other fields in your form. By implementing conditional logic, you can create more intuitive and streamlined user interfaces that only display relevant fields when they're needed.

With conditional fields, you can:

- Show or hide fields based on the state of other form inputs
- Create cleaner, less cluttered forms by revealing fields only when necessary
- Improve the user experience by presenting a more focused interface

The conditional display is powered by Alpine.js expressions, giving you flexibility in defining when fields should appear.

```
# models.pyfrom django.contrib.auth.models import AbstractUserfrom django.utils.translation import gettext_lazy as _class User(AbstractUser):    different_address = models.BooleanField(_("different address"), default=False)    country = models.CharField(_("city"), max_length=255, null=True, blank=True, default=None)    city = models.CharField(_("city"), max_length=255, null=True, blank=True, default=None)    address = models.CharField(_("address"), max_length=255, null=True, blank=True, default=None)    class Meta:        db_table = "users"        verbose_name = _("user")        verbose_name_plural = _("users")
```

# **Implementing Conditional Fields**

Using the model defined above, we can implement conditional field display by configuring the **`conditional_fields`** dictionary in our ModelAdmin class. This powerful feature allows for dynamic form behavior based on user input.

The **`conditional_fields`** dictionary uses a straightforward key-value structure: - Each **key** corresponds to a field name from your model that you want to conditionally display - Each **value** contains JavaScript/Alpine.js expression that evaluates to either true or false, determining whether the field should be visible

When a user interacts with your form, Django Unfold evaluates these expressions in real-time, showing or hiding fields accordingly. This creates a responsive, interactive experience without requiring page reloads.

For fields that use multiple widgets (like SplitDateTimeField), Django Unfold automatically handles the complexity by assigning numeric suffixes to each widget component. For example, a date-time field named **`date_start`** would have its widgets accessible as **`date_start_0`** and **`date_start_1`** in your conditional expressions.

This approach is particularly useful for complex forms where certain information is only relevant based on specific user choices, helping to reduce visual clutter and guide users through your interface more effectively.

```
# admin.pyfrom django.contrib import adminfrom unfold.admin import ModelAdminfrom .models import User@admin.register(User)class UserAdmin(ModelAdmin):    conditional_fields = {        "country": "different_address == true"        "city": "different_address == true"        "address": "different_address == true"    }
```

# **Paginator**

Django Unfold provides a specialized paginator called **`InfinitePaginator`** designed specifically for handling large datasets efficiently. When working with tables containing millions of records, standard Django pagination can become slow due to expensive **`COUNT`** queries that calculate the total number of records.

# **InfinitePaginator**

The **`InfinitePaginator`** offers several advantages for large dataset management:

- Eliminates expensive **`COUNT`** operations on the database
- Displays simplified navigation with only "Previous" and "Next" links
- Removes the upper limit on page numbers
- Significantly improves performance for very large tables

# **Implementation**

To use the **`InfinitePaginator`** in your admin interface, simply configure your ModelAdmin class as follows:

```
from unfold.admin import ModelAdminfrom unfold.paginator import InfinitePaginatorclass YourAdmin(ModelAdmin):    paginator = InfinitePaginator    show_full_result_count = False
```

# **Crispy Forms**

Django Crispy Forms is a powerful form rendering application that enhances the way forms are displayed in Django projects. It provides a comprehensive solution for controlling form rendering behavior with a clean, DRY (Don't Repeat Yourself) approach.

Key features for creating beautiful forms in Unfold:

- **Template packs**: Support for various template packs. Unfold provides its own template pack called **`unfold_crispy`**
- **Form layouts**: Define form layouts programmatically with FormHelper
- **Layout objects**: Create complex form layouts using layout objects like Div, Row, Column, and Fieldset
- **Reduced boilerplate**: Eliminate repetitive HTML in templates
- **Consistent styling**: Maintain consistent form styling across your application

# **Installation**

1. Install django-crispy-forms using pip:

```
pip install django-crispy-formsuv add django-crispy-formspoetry add django-crispy-forms
```

1. Add **`crispy_forms`** to your **`INSTALLED_APPS`** in **`settings.py`**. Of course, the Unfold dependency is required in **`INSTALLED_APPS`** for **`unfold_crispy`** template pack support.

```
INSTALLED_APPS = [    "unfold",    ...    "crispy_forms",    ...]
```

1. Configure Crispy Forms to use the Unfold template pack. Add these settings to your **`settings.py`**:

```
CRISPY_TEMPLATE_PACK = "unfold_crispy"CRISPY_ALLOWED_TEMPLATE_PACKS = ["unfold_crispy"]
```

If you're already using a different template pack for your front-end application, you may want to skip setting **`CRISPY_TEMPLATE_PACK`** globally as it would override your front-end styling. Instead, you can use Crispy Forms template tags with the explicitly specified template pack parameter **`"unfold_crispy"`** in your admin views.

# **Crispy Forms with custom Unfold admin form**

To integrate Crispy Forms with Unfold admin, start by creating a custom form with all necessary field specifications and validation rules. The example below demonstrates a basic implementation using **`forms.Form`**, though you can also use **`forms.ModelForm`** for model-based forms. After defining your form, add the FormHelper from crispy_forms.helper to configure your form's layout and behavior. The **`FormHelper`** allows you to organize your form fields using **`Layout`** objects for optimal display in the Unfold admin interface.

```
# forms.pyfrom crispy_forms.helper import FormHelperfrom crispy_forms.layout import Layoutfrom django import formsclass CustomForm(forms.Form):    pass    def __init__(self, *args, **kwargs):        super().__init__(*args, **kwargs)        self.helper = FormHelper()        self.helper.layout = Layout(            "field1", "field2"        )
```

Once you've created your form with Crispy Forms, you'll need to integrate it with Django's view system. The recommended approach is to use Django's class-based **`FormView`** along with Unfold's admin mixins.

Create a view that inherits from both **`UnfoldModelAdminViewMixin`** and Django's **`FormView`**. Configure the view with appropriate permissions and templates, and set your custom form as the **`form_class`**. This integration allows you to maintain Unfold's admin styling and functionality while leveraging Crispy Forms' layout capabilities.

**Note:** This view must be [**registered as a custom page**](https://unfoldadmin.com/docs/pages/) in your admin configuration.

```
# views.pyfrom django.views.generic import FormViewfrom unfold.views import UnfoldModelAdminViewMixinfrom .forms import CustomFormclass MyClassBasedView(UnfoldModelAdminViewMixin,FormView):    title = "Custom Title"    form_class = CustomForm    success_url = reverse_lazy("admin:index")    permission_required = (        "app_name.add_model_name",        "app_name.change_model_name",    )    template_name = "app_name/some_template.html"
```

In your template, use the **`crispy`** template tag to render the form with Unfold's styling. The **`crispy`** tag automatically applies the form layout defined in your FormHelper.

For consistent styling with the Unfold admin interface, specify the **`"unfold_crispy"`** template pack as the second parameter to the **`crispy`** tag. This ensures your form elements will match Unfold's design system.

```
{% load crispy_forms_tags %}{% block extrahead %}    {{ block.super }}    <script src="{% url 'admin:jsi18n' %}"></script>    {{ form.media }}{% endblock %}{% block content %}    {% crispy form "unfold_crispy" %}{% endblock %}
```

![Django Crispy Form](https://unfoldadmin.com/static/docs/configuration/django-crispy-forms.webp)

To see a live example of Django Crispy Forms integration with Unfold, visit our [**interactive demo site**](https://demo.unfoldadmin.com/en/admin/formula/driver/crispy-form). This demo showcases a fully functional form implementation using the techniques described above, including custom layouts, widgets, and styling. You can explore the form's behavior, test its validation, and see how it seamlessly integrates with Unfold's admin interface design. The source code for this demo is also available in our [**GitHub repository**](https://github.com/unfoldadmin/django-unfold), making it easy to reference when building your own forms.

# **Creating formsets with django-crispy-forms**

![Django Crispy Form](https://unfoldadmin.com/static/docs/configuration/django-crispy-formset.webp)

For a comprehensive demonstration of django-crispy-forms with formset functionality in Unfold, we've created a [**live example**](https://demo.unfoldadmin.com/en/admin/formula/driver/crispy-with-formset) that you can explore. This demo showcases how to implement dynamic formsets with proper styling and functionality, including the ability to add/remove rows dynamically while maintaining Unfold's design system. The demo is particularly useful for understanding how formsets integrate with Unfold's admin interface and how to properly configure the FormHelper for optimal formset handling.

Below you can find a complete example demonstrating formset implementation with django-crispy-forms in Unfold. This example shows how to create dynamic formsets with proper styling, form helpers, and view configuration. The code includes all necessary components for a fully functional formset that allows adding and removing rows while maintaining Unfold's design system:

```
# forms.pyfrom django import formsfrom unfold.layout import Submitfrom crispy_forms.layoutfrom crispy_forms.helper import FormHelperclass YourModelFormHelper(FormHelper):    def __init__(self, *args, **kwargs):        super().__init__(*args, **kwargs)        self.template = "unfold_crispy/layout/table_inline_formset.html"        self.form_id = "your-model-formset" # This is important to add for dynamic rows        self.form_add = True        self.attrs = {            "novalidate": "novalidate",        }        self.add_input(Submit("submit", _("Another submit")))        self.add_input(Submit("submit", _("Submit")))class YourModelForm(forms.ModelForm):    class Meta:        model = YourModel        fields = [            "first_name",            "last_name",            "code",        ]        widgets = {            "first_name": UnfoldAdminTextInputWidget(),            "last_name": UnfoldAdminTextInputWidget(),            "code": UnfoldAdminTextInputWidget(),        }
```

```
# views.pyfrom .forms import YourModelFormHelperclass CrispyFormsetView(UnfoldModelAdminViewMixin,FormView):    title = _("Crispy form with formset")  # required: custom page header title    success_url = reverse_lazy("admin:custom_path")    permission_required = ("app.your_permission", )# required: tuple of permissions    template_name = "app/formset_template.html"    def get_form_class(self):        return modelformset_factory(YourModel, YourModelForm, extra=1, can_delete=True)    def form_valid(self, form):        messages.success(self.request, _("Formset submitted successfully"))        return super().form_valid(form)    def get_context_data(self, **kwargs):        context = super().get_context_data(**kwargs)        context.update(            {                "your_model_formset_helper":  YourModelFormHelper(),            }        )        return context
```

```
{% extends "admin/base.html" %}{% load admin_urls crispy_forms_tags i18n unfold %}{% block extrahead %}    {{ block.super }}    <script src="{% url 'admin:jsi18n' %}"></script>{% endblock %}{% block content %}    <div class="flex flex-col gap-8">        {% crispy form your_model_formset_helper "unfold_crispy" %}    </div>{% endblock %}
```

# **Sections - expandable changelist rows**

Unfold implements special functionality for handling expandable rows in changelists called sections. Once the **`list_sections`** attribute is configured, rows in the changelist will display an arrow button at the beginning of the row which can be used to show additional content.

![Unfold Sections](https://unfoldadmin.com/static/docs/configuration/unfold-sections.webp)

The **`list_sections`** attribute consists of Python classes inheriting from **`TableSection`** or **`TemplateSection`** defined in **`unfold.sections`**. These classes are responsible for rendering the content in the expandable area.

```
from unfold.admin import ModelAdminfrom unfold.sections import TableSection, TemplateSectionfrom .models import SomeModel# Table for related recordsclass CustomTableSection(TableSection):    verbose_name = _("Table title")  # Displays custom table title    height = 300  # Force the table height. Ideal for large amount of records    related_name = "related_name_set"  # Related model field name    fields = ["pk", "title", "custom_field"]  # Fields from related model    # Custom field    def custom_field(self, instance):        return instance.pk# Simple template with custom contentclass CardSection(TemplateSection):    template_name = "your_app/some_template.html"@admin.register(SomeModel)class SomeAdmin(ModelAdmin):    list_sections = [        CardSection,        CustomTableSection,    ]
```

# **Query optimisation**

When it comes to classes inheriting from **`TableSection`**, you may find a problem with an extraordinary amount of queries executed on changelist pages. This problem has two parts:

1. **`TableSection`** works with related fields so another query is required to obtain data from the related table
2. The default page size for changelist is configured to 100 - which is a pretty large number of records per page

The easiest solution for this issue is to configure pagination to a smaller amount of records by setting **`list_per_page = 20`**. While this solution might work for you, it is not optimal.

The optimal solution is using [**`prefetch_related`**](https://docs.djangoproject.com/en/5.1/ref/models/querysets/#prefetch-related):

1. Install [**django-debug-toolbar**](https://github.com/django-commons/django-debug-toolbar) and check all SQL queries that are duplicating for each record in the changelist
2. Override **`get_queryset`** and use **`prefetch_related`** on all related rows until you don't have any duplicated SQL queries in django-debug-toolbar output

```
from unfold.admin import ModelAdminfrom .models import SomeModel@admin.register(SomeModel)class SomeAdmin(ModelAdmin):    list_per_page = 20  # Quick solution    list_sections = [CustomTableSection]    # Custom queryset prefetching related records    def get_queryset(self, request):        return (            super()            .get_queryset(request)            .prefetch_related(                "related_field_set",                "related_field__another_related_field",                "related_field__another_related_field__even_more_related_field",            )        )
```

# **Multiple related tables**

Unfold supports multiple related tables in expandable rows. Specify a section class for each related field and put them into **`list_sections`**. For each class, you can add a **`verbose_name`** to display a custom title right above the table to distinguish between different related fields.

```
from unfold.admin import ModelAdminfrom .models import SomeModel@admin.register(SomeModel)class SomeAdmin(ModelAdmin):    list_sections = [         CustomTableSection, OtherCustomTable    ]
```

# **Custom pages**

By default, Unfold provides a basic view mixin which helps with creation of basic views which are part of Unfold UI. The implementation requires creation of class based view inheriting from **`unfold.views.UnfoldModelAdminViewMixin`**. It is important to add **`title`** and **`permission_required`** properties.

```
# admin.pyfrom django.urls import pathfrom django.views.generic import TemplateViewfrom unfold.admin import ModelAdminfrom unfold.views import UnfoldModelAdminViewMixinfrom .models import MyModelclass MyClassBasedView(UnfoldModelAdminViewMixin,TemplateView):    title = "Custom Title"  # required: custom page header title    permission_required = () # required: tuple of permissions    template_name = "some/template/path.html"@admin.register(MyModel)class CustomAdmin(ModelAdmin):    def get_urls(self):        # IMPORTANT: model_admin is required        custom_view = self.admin_site.admin_view(            MyClassBasedView.as_view(model_admin=self)        )        return super().get_urls() + [            path(                "custom-url-path", custom_view, name="custom_name"            ),        ]
```

The template is straightforward, extend from **`unfold/layouts/base.html`** and the UI will display all Unfold components like header or sidebar with all menu items. Then all content needs to be located in **`content`** block. Below you can find full example from the Formula project implementing additional components:

- Breadcrumbs: it is up to developer to construct own breadcrumbs
- Tab list: in case your project has dynamic tabs, you can use **`tab_list`** helper to display them

```
{% extends "admin/base.html" %}{% load admin_urls i18n unfold %}{% block breadcrumbs %}{% if not is_popup %}    <div class="px-4">        <div class="container mb-6 mx-auto -my-3 lg:mb-12">            <ul class="flex flex-wrap">                {% url 'admin:index' as link %}                {% trans 'Home' as name %}                {% include 'unfold/helpers/breadcrumb_item.html' with link=link name=name %}                {% url 'admin:formula_driver_changelist' as link %}                {% trans 'Drivers' as name %}                {% include 'unfold/helpers/breadcrumb_item.html' with link=link name=name %}                {% trans 'Custom page' as name %}                {% include 'unfold/helpers/breadcrumb_item.html' with name=name %}            </ul>        </div>    </div>{% endif %}{% endblock %}{% block content %}    {% tab_list "drivers" %}    {% trans "Custom page" %}{% endblock %}
```

**Note:** custom view is not by default added into sidebar navigation. It has to be added manually into sidebar in **UNFOLD** settings.

# **Admin dashboard**

To customize your admin dashboard, start by creating a new file at **`templates/admin/index.html`** in your project directory. This file will serve as your custom dashboard template. You can use the base template provided below as a starting point for your customization.

It's important to note that when you add custom styles to this template, they won't be automatically compiled and applied. This is because the CSS classes are specific to your project rather than being part of the core Unfold package. To properly implement your custom styling, you'll need to configure Tailwind CSS for your project or you can write your own custom CSS styles without using Tailwind at all.

For detailed instructions on setting up Tailwind CSS and ensuring your custom styles are properly compiled and applied, please refer to our comprehensive guide in the [**Project Level Tailwind Stylesheet**](https://unfoldadmin.com/docs/styles-scripts/customizing-tailwind/) chapter. This guide will walk you through the necessary steps to integrate Tailwind with your project and enable custom styling for your dashboard.

Ensure you have set up the template directory in **`settings.py`**

```
TEMPLATES = [    {        'BACKEND': 'django.template.backends.django.DjangoTemplates',        'DIRS': [BASE_DIR / "templates"],  # Ensure this line is added        #....    }
```

```
{% extends 'admin/base.html' %}{% load i18n %}{% block breadcrumbs %}{% endblock %}{% block title %}    {% if subtitle %}        {{ subtitle }} |    {% endif %}    {{ title }} | {{ site_title|default:_('Django site admin') }}{% endblock %}{% block branding %}    {% include "unfold/helpers/site_branding.html" %}{% endblock %}{% block content %}    Start creating your own Tailwind components here{% endblock %}
```

# **Custom variables**

When building a new dashboard, you'll often need to display data from your database. Unfold provides a special **`DASHBOARD_CALLBACK`** parameter that allows you to pass custom variables to your **`templates/admin/index.html`** template through a dictionary.

```
# views.pydef dashboard_callback(request, context):    context.update({        "custom_variable": "value",    })    return context
```

```
# settings.pyUNFOLD = {    "DASHBOARD_CALLBACK": "app.views.dashboard_callback",}
```

# **Custom sites**

In order to create a custom admin site, Unfold provides the **`unfold.sites.UnfoldAdminSite`** class which can be used as follows:

```
# sites.pyfrom django.contrib import adminfrom unfold.sites import UnfoldAdminSiteclass CustomAdminSite(UnfoldAdminSite):    passcustom_admin_site = CustomAdminSite(name="custom_admin_site")
```

```
# urls.pyfrom django.urls import pathfrom .sites import custom_admin_siteurlpatterns = [    # other URL patterns    path("admin/", custom_admin_site.urls),]
```

```
# models.pyfrom django.contrib.auth.models import Userfrom unfold.admin import ModelAdmin@admin.register(User, site=custom_admin_site)class UserAdmin(ModelAdmin):    model = User
```

**Note**: If you use the default **`django.contrib.admin.AdminSite`** you will receive a **`NoReverseMatch`** error because the default admin site does not contain all URL patterns required by Unfold.

# **Overriding the default admin site**

If you want to override the default admin site by setting the **`default_site`** attribute of a custom **`django.contrib.admin.apps.AdminConfig`** class, you must install Unfold using **`unfold.apps.AppConfig`** instead of just **`unfold`** in **`INSTALLED_APPS`**.

```
# settings.pyINSTALLED_APPS = [    "unfold.apps.BasicAppConfig", # App config not overriding `django.contrib.admin.site`    # some other apps    "django.contrib.admin",    "your_app",]
```

```
# apps.pyfrom django.contrib.admin.apps import AdminConfigclass MyAdminConfig(AdminConfig):    default_site = "myproject.sites.CustomAdminSite"    def get_urls(self):        urls = super().get_urls()        urls += [            path("my-custom-view/", self.admin_view(self.my_custom_view), name="my_custom_view"),        ]        return urls    def my_custom_view(self, request, extra_context = None):        # Your custom business logic        pass
```

# **Multi-language support**

To enable multi-language support in your Django admin interface, you'll need to make several configuration changes in your settings. First, add the **`django.middleware.locale.LocaleMiddleware`** to your **`MIDDLEWARE`** setting - this middleware handles language selection based on user preferences. Next, enable internationalization by setting **`USE_I18N = True`**. You'll also need to specify your default language using **`LANGUAGE_CODE`** and define the available languages in the **`LANGUAGES`** setting. Once you've made these configuration changes, your Django admin site will be fully prepared to handle multiple languages and provide language-switching capabilities to your users.

![Unfold site dropdown](https://unfoldadmin.com/static/docs/configuration/unfold-multilanguage.webp)

```
# settings.pyMIDDLEWARE = [    "django.middleware.locale.LocaleMiddleware",]LANGUAGE_CODE = "en"USE_I18N = TrueLANGUAGES = (    ("de", _("German")),    ("en", _("English")),)
```

Below you can find an example of how to add support for multiple languages in Django admin. Once you have this setup, you will be able to access the admin in different languages. In our case we have two languages, English and German so our admin will be available in **`/en/admin/`** and **`/de/admin/`**. If you visit **`/admin/`** you will see the default language which is English and you will be redirected to **`/en/admin/`**.

The **`path("i18n/", include("django.conf.urls.i18n")),`** is needed for the language selector to work. This line of code is going to provide a view which will be used to change the language. Make sure that this line is not defined in **`i18n_patterns`**.

```
# urls.pyfrom django.conf.urls.i18n import i18n_patternsfrom django.urls import include, pathurlpatterns = (    [        path("i18n/", include("django.conf.urls.i18n")),    ]    + i18n_patterns(        path("admin/", admin.site.urls),    ))
```

To display the language selector in the admin, you need to add **`UNFOLD = {"SHOW_LANGUAGES": True,}`** to your **`settings.py`** file. The language selector will be displayed in the top right corner of the admin.

```
# settings.pyUNFOLD = {    "SHOW_LANGUAGES": True,}
```

# **Overriding language options**

By default, Django Unfold will automatically detect and display all available languages configured in your Django project's **`LANGUAGES`** setting. However, there are scenarios where you might want to customize which languages appear in the language selector or how they are presented to users. Django Unfold provides flexible configuration options that allow you to override the default language detection behavior and provide your own custom list of languages for the navigation interface.

This customization capability is particularly useful when you want to:

- Display only a subset of your configured languages in the admin interface
- Present languages in a specific order that differs from your Django settings
- Use custom language names or translations that better suit your admin users
- Implement dynamic language selection based on user permissions or other criteria
- Integrate with external language management systems or APIs

The language override functionality gives you complete control over both the languages that appear in the selector and how the language switching mechanism behaves within the admin interface.

```
from django.utils.translation import get_language_infoUNFOLD = {    "LANGUAGES": {        # Hardcoded list of languages        "navigation": [            {                'bidi': False,                'code': 'de',                'name': 'German',                'name_local':                'Deutsch',                'name_translated': 'German'            },        ],        # Using a callback to generate list of languages        # "navigation": "your_app.utils.languages_callback",        # In case you want to have some custom form handling        # "actions": reverse_lazy("custom_form_submit")    }}# def languages_callback(request):#     return [get_language_info(lang) for lang in ["en", "de", "fr"]]
```

# Filters

# **Filters**

By default, Django's admin interface handles filtering through regular HTML links that modify URL query parameters. While this approach works well for basic filtering needs, it becomes limiting when dealing with more advanced filtering requirements, particularly when input fields are involved.

Unfold extends Django's filtering capabilities through its custom filters, which are contained in a dedicated application called **`unfold.contrib.filters`**. To utilize these enhanced filtering features in your project, you'll need to add this application to your **`INSTALLED_APPS`** configuration in **`settings.py`**. It's important to place it immediately after the main **`unfold`** application to ensure proper functionality.

```
# settings.pyINSTALLED_APPS = [    "unfold",    "unfold.contrib.filters",]
```

**Note:** When implementing filters with input fields, users need a way to submit their values since default filters don't include a submit button. To add a submit button to the filter form, set the **`list_filter_submit`** boolean flag to **`True`** in your **`unfold.admin.ModelAdmin`** class.

# **Text filters**

The text input field provides a flexible filtering mechanism that allows users to search using any string they input. Unfold offers two distinct variants of this filter: **`FieldTextFilter`** and **`TextFilter`**, each serving different use cases.

The **`FieldTextFilter`** is straightforward to implement, requiring only a model field name. It automatically performs a case-insensitive search (using **`__icontains`**) on the specified field. Configuration is minimal - you simply need to add a tuple containing the model field name and **`FieldTextFilter`** to your **`list_filter`** configuration, like this: **`("model_field_name", FieldTextFilter)`**.

For more complex filtering requirements, the **`TextFilter`** offers greater flexibility. To use it, you'll need to create a new class that inherits from **`TextFilter`** and implement a custom **`queryset`** method. You'll also need to specify a **`parameter_name`** attribute, which defines how the search parameter will appear in the URL. The main advantage of **`TextFilter`** is its ability to handle sophisticated query logic, allowing you to create highly customized filtering behavior.

![Text filter](https://unfoldadmin.com/static/docs/filters/text-filter.webp)

```
from django.contrib import adminfrom django.contrib.auth.models import Userfrom django.core.validators import EMPTY_VALUESfrom django.utils.translation import gettext_lazy as _from unfold.admin import ModelAdminfrom unfold.contrib.filters.admin import TextFilter, FieldTextFilterclass CustomTextFilter(TextFilter):    title = _("Custom filter")    parameter_name = "query_param_in_uri"    def queryset(self, request, queryset):        if self.value() not in EMPTY_VALUES:            # Here write custom query            return queryset.filter(your_field=self.value())        return queryset@admin.register(User)class MyAdmin(ModelAdmin):    list_filter_submit = True  # Submit button at the bottom of the filter    list_filter = [        ("model_charfield", FieldTextFilter),        CustomTextFilter    ]
```

# **Datetime filters**

Unfold offers two powerful datetime filtering options: the **`RangeDateFilter`** for date-only fields and the **`RangeDateTimeFilter`** for datetime fields. These filters are both implemented within the **`unfold.contrib.filters`** application, so you'll need to ensure this application is included in your project's **`INSTALLED_APPS`** configuration within **`settings.py`** for proper functionality.

![Datetime filter](https://unfoldadmin.com/static/docs/filters/datetime-filter.webp)

```
# admin.pyfrom django.contrib import adminfrom django.contrib.auth.models import Userfrom unfold.admin import ModelAdminfrom unfold.contrib.filters.admin import RangeDateFilter, RangeDateTimeFilter@admin.register(User)class YourModelAdmin(ModelAdmin):    list_filter_submit = True  # Submit button at the bottom of the filter    list_filter = (        ("field_E", RangeDateFilter),  # Date filter        ("field_F", RangeDateTimeFilter),  # Datetime filter    )
```

# **Dropdown filters**

Dropdown filters enhance your Django admin interface by providing select fields with customizable lists of options. Unfold offers two primary types of dropdown filters: **`ChoicesDropdownFilter`** and **`RelatedDropdownFilter`**, each serving different use cases.

The key distinction between these filters lies in how they source their options. The **`ChoicesDropdownFilter`** generates its list of options by utilizing the **`choices`** attribute defined on a model field. This makes it particularly well-suited for use with **`CharField`** fields that have predefined choices. In contrast, the **`RelatedDropdownFilter`** is designed to work with one-to-many or many-to-many foreign key relationships, automatically populating the dropdown with related model instances. This flexibility allows you to create intuitive filtering interfaces based on your data model structure.

![Related dropdown filter](https://unfoldadmin.com/static/docs/filters/related-dropdown-filter.webp)

```
# admin.pyfrom django.contrib import adminfrom django.contrib.auth.models import Userfrom unfold.admin import ModelAdminfrom unfold.contrib.filters.admin import (    ChoicesDropdownFilter,    MultipleChoicesDropdownFilter,    RelatedDropdownFilter,    MultipleRelatedDropdownFilter,    DropdownFilter,    MultipleDropdownFilter)class CustomDropdownFilter(DropdownFilter):    title = _("Custom dropdown filter")    parameter_name = "query_param_in_uri"    def lookups(self, request, model_admin):        return [            ["option_1", _("Option 1")],            ["option_2", _("Option 2")],        ]    def queryset(self, request, queryset):        if self.value() not in EMPTY_VALUES:            # Here write custom query            return queryset.filter(your_field=self.value())        return queryset@admin.register(User)class MyAdmin(ModelAdmin):    list_filter_submit = True  # Submit button at the bottom of the filter    list_filter = [        CustomDropdownFilter,        ("modelfield_with_choices", ChoicesDropdownFilter),        ("modelfield_with_choices_multiple", MultipleChoicesDropdownFilter),        ("modelfield_with_foreign_key", RelatedDropdownFilter)        ("modelfield_with_foreign_key_multiple", MultipleRelatedDropdownFilter)    ]
```

**Note:** At the moment Unfold does not implement a dropdown with an autocomplete functionality, so it is important not to use dropdowns displaying large datasets.

**Note:** All dropdowns are using Select2 for better UX by default. Native implementation with simple select dropdown is not available.

# **Numeric filters**

Unfold provides numeric filtering capabilities through its **`unfold.contrib.filters`** application. To utilize these powerful filtering features in your project, you'll need to add this application to your **`INSTALLED_APPS`** configuration in **`settings.py`**. Make sure to place it immediately after the **`unfold`** application to ensure proper functionality and dependency resolution.

![Numeric filter](https://unfoldadmin.com/static/docs/filters/numeric-filter.webp)

```
# admin.pyfrom django.contrib import adminfrom django.contrib.auth.models import Userfrom unfold.admin import ModelAdminfrom unfold.contrib.filters.admin import (    RangeNumericListFilter,    RangeNumericFilter,    SingleNumericFilter,    SliderNumericFilter,)class CustomSliderNumericFilter(SliderNumericFilter):    MAX_DECIMALS = 2    STEP = 10class CustomRangeNumericListFilter(RangeNumericListFilter):    parameter_name = "items_count"    title = "items"@admin.register(User)class YourModelAdmin(ModelAdmin):    list_filter_submit = True  # Submit button at the bottom of the filter    list_filter = (        ("field_A", SingleNumericFilter),  # Numeric single field search, __gte lookup        ("field_B", RangeNumericFilter),  # Numeric range search, __gte and __lte lookup        ("field_C", SliderNumericFilter),  # Numeric range filter but with slider        ("field_D", CustomSliderNumericFilter),  # Numeric filter with custom attributes        CustomRangeNumericListFilter,  # Numeric range search not restricted to a model field    )    def get_queryset(self, request):        return super().get_queryset().annotate(items_count=Count("item", distinct=True))
```

# **Horizontal layout filter**

Unfold provides a horizontal layout for filter choices in the changelist view. By default, the layout for filter choices is vertical but by providing the **`horizontal`** attribute set to **`True`** to the filter class, the layout will be horizontal.

```
# admin.pyfrom django.contrib import adminfrom django.contrib.auth import get_user_modelfrom django.contrib.admin.filters import ChoicesFieldListFilterfrom unfold.admin import ModelAdminUser = get_user_model()class HorizontalChoicesFieldListFilter(ChoicesFieldListFilter):    horizontal = True # Enable horizontal layout@admin.register(User)class UserAdmin(ModelAdmin):    list_filter = (        ["other_model_field", HorizontalChoicesFieldListFilter],    )
```

# **Autocomplete filters**

Unfold enhances Django's filtering capabilities by providing two distinct types of autocomplete filters: **`AutocompleteSelectFilter`** for single selection and **`AutocompleteSelectMultipleFilter`** for multiple selections. Both filters are implemented within the **`unfold.contrib.filters`** package, so you'll need to ensure this app is properly included in your **`INSTALLED_APPS`** configuration within **`settings.py`**.

For these filters to work correctly, there are two key requirements: First, the fields you want to filter must be either **`ForeignKey`** or **`ManyToManyField`** relationships. Second, the referenced admin model must have the **`search_fields`** attribute properly defined to enable the search functionality. If either of these requirements is not met, the application will raise an error to alert you of the misconfiguration.

![Autocomplete select filter](https://unfoldadmin.com/static/docs/filters/autocomplete-select-filter.webp)

```
# admin.pyfrom django.contrib import adminfrom django.contrib.auth.models import Userfrom unfold.admin import ModelAdminfrom unfold.contrib.filters.admin import (    AutocompleteSelectFilter,    AutocompleteSelectMultipleFilter)@admin.register(User)class YourModelAdmin(ModelAdmin):    list_filter = (        # Autocomplete filter        ["other_model_field", AutocompleteSelectFilter],        # Autocomplete multiple filter        ["other_multiple_model_field", AutocompleteSelectMultipleFilter],    )class OtherModelAdmin(ModelAdmin):    search_fields = ["name"]
```

# **Checkbox and radio filters**

Checkbox and radio filters display all options at once for easier selection, ideal for scenarios with a manageable number of filtering options. Unfold provides radio filters (single selection), checkbox filters (multiple selection), and specialized versions for different field types, making filtering more intuitive and accessible than traditional dropdowns.

# **Radio or checkbox filters for fields with choices**

Unfold provides specialized filters for model fields that have predefined choices. These filters enhance the user experience by displaying the choices as either radio buttons or checkboxes instead of the default dropdown.

- These filters work with any model field that contains the **`choices`** property (typically **`CharField`** with choices)
- The library supports both radio button inputs (**`ChoicesRadioFilter`**) and checkbox inputs (**`ChoicesCheckboxFilter`**)
- When using the radio button filter (**`ChoicesRadioFilter`**), an "All" option is automatically added at the beginning of the list, allowing users to clear their selection
- The checkbox filter (**`ChoicesCheckboxFilter`**) allows for selecting multiple options simultaneously

![Choices checkbox filter](https://unfoldadmin.com/static/docs/filters/choices-checkbox-filter.webp)

These filters are particularly useful when you have a reasonable number of choices that would benefit from being all visible at once, rather than hidden in a dropdown menu.

```
from unfold.contrib.filters.admin import ChoicesRadioFilter, ChoicesCheckboxFilterclass SampleModelAdmin(ModelAdmin):    list_filter = [        ("status", ChoicesCheckboxFilter),        ("status", ChoicesRadioFilter)    ]
```

# **Radio filter for BooleanField**

For boolean fields (**`django.db.models.BooleanField`**), Unfold provides a specialized filter called **`BooleanRadioFilter`**. This filter enhances the user experience by displaying the boolean options (Yes/No) as radio inputs, making it more intuitive and visually appealing compared to the default dropdown.

![Boolean radio filter](https://unfoldadmin.com/static/docs/filters/boolean-radio-filter.webp)

The **`BooleanRadioFilter`** automatically includes an "All" option, allowing users to clear their selection and view all records regardless of the boolean field value. This is particularly useful when filtering through large datasets where you need to toggle between filtered and unfiltered views.

Here's how to implement the **`BooleanRadioFilter`** in your admin configuration:

```
from unfold.contrib.filters.admin import BooleanRadioFilterclass SampleModelAdmin(ModelAdmin):    list_filter = [        ("is_active", BooleanRadioFilter)    ]
```

# **Checkbox related field filter**

The **`RelatedCheckboxFilter`** is designed to work with foreign key relationships in your models. This filter displays related objects as a list of checkboxes, allowing users to select multiple values simultaneously. It's particularly useful when filtering by related models where you want to provide a more visual and accessible interface than a standard dropdown.

```
from unfold.contrib.filters.admin import RelatedCheckboxFilterclass SampleModelAdmin(ModelAdmin):    list_filter = [        ("country", RelatedCheckboxFilter)    ]
```

# **Displaying all values in field**

The **`AllValuesCheckboxFilter`** provides a checkbox interface that automatically displays all distinct values found in the database column for the specified field. This filter functions similarly to Django's built-in **`AllValuesFieldListFilter`**, but enhances the user experience by presenting all available options as checkboxes instead of a dropdown menu. This approach allows users to see all possible values at once and select multiple options simultaneously, making it particularly useful for fields with a moderate number of distinct values that users frequently need to filter by.

![All values checkbox filter](https://unfoldadmin.com/static/docs/filters/all-values-checkbox-filter.webp)

```
from unfold.contrib.filters.admin import AllValuesCheckboxFilterclass SampleModelAdmin(ModelAdmin):    list_filter = [        ("option", AllValuesCheckboxFilter)    ]
```

# **Custom checkbox or radio filter**

For custom filtering requirements, Unfold allows you to create your own checkbox or radio filters by extending the base filter classes. This gives you complete control over the filter's behavior, appearance, and the underlying query logic.

You can create custom filters by extending either the **`RadioFilter`** or **`CheckboxFilter`** base classes, depending on whether you want single or multiple selection capability.

```
from unfold.contrib.filters.admin import RadioFilterclass CustomRadioFilter(RadioFilter):    title = _("Custom radio filter")    parameter_name = "query_param_in_uri"    def lookups(self, request, model_admin):        return [            ["option_1", _("Option 1")],            ["option_2", _("Option 2")],        ]    def queryset(self, request, queryset):        if self.value() not in EMPTY_VALUES:            # Here write custom query            return queryset.filter(your_field=self.value())        return queryset
```

# Actions

# **Actions**

It is highly recommended to read the base [**Django actions documentation**](https://docs.djangoproject.com/en/5.1/ref/contrib/admin/actions/) before reading this section, since Unfold actions are derived from Django actions.

```
# admin.pyfrom django.auth.models import Userfrom django.contrib import adminfrom django.db.models import QuerySetfrom django.http import HttpRequestfrom unfold.admin import ModelAdminfrom unfold.decorators import action@admin.register(User)class UserAdmin(ModelAdmin):    actions_list = ["custom_action"]    @action(description="Custom action", icon="person")    def custom_action(self, request: HttpRequest, queryset: QuerySet):        pass
```

# **Permissions**

Unfold provides two distinct ways to handle permissions for actions:

1. **ModelAdmin Method-based Permissions**
2. Define a permission check method in your ModelAdmin class
3. The method name should follow the pattern **`has_{permission_name}_permission`**
4. This method receives the request and can optionally receive the object instance
5. Example: **`has_custom_action_permission`** for a permission named "custom_action"
6. **Django Built-in Permissions**
7. Use Django's permission system with the format **`app_label.permission_codename`**
8. These are standard Django permissions defined in your models
9. **Note:** When using built-in permissions (containing a dot in the string), the permission check will not receive the object instance during detail view checks

```
from django.contrib import adminfrom django.contrib.auth.models import Userfrom unfold.admin import ModelAdminfrom unfold.decorators import action@admin.register(User)class UserAdmin(ModelAdmin):    @action(        description="Custom action",        permissions=["custom_action", "auth.view_user"]  # Using both permission types    )    def custom_action(self, request, queryset):        pass    def has_custom_action_permission(self, request, obj=None):        # Custom permission logic here        return request.user.is_superuser
```

# **Icon support**

Unfold supports custom icons for actions. Icons are supported for all actions types. You can set the icon for an action by providing **`icon`** parameter to the **`@action`** decorator.

```
# admin.pyfrom django.db.models import QuerySetfrom django.http import HttpRequestfrom unfold.decorators import action@action(description="Custom action", icon="person")def custom_action(self, request: HttpRequest, queryset: QuerySet):    pass
```

# **Action variants**

In Unfold it is possible to change a color of the action. Unfold supports different variants of actions. You can set the variant for an action by providing **`variant`** parameter to the **`@action`** decorator.

```
# admin.pyfrom django.db.models import QuerySetfrom django.http import HttpRequestfrom unfold.decorators import action# Import ActionVariant enum from Unfold to set action variantfrom unfold.enums import ActionVariant# class ActionVariant(Enum):#     DEFAULT = "default"#     PRIMARY = "primary"#     SUCCESS = "success"#     INFO = "info"#     WARNING = "warning"#     DANGER = "danger"@action(description="Custom action", variant=ActionVariant.PRIMARY)def custom_action(self, request: HttpRequest, queryset: QuerySet):    pass
```

# **Actions overview**

Besides traditional actions selected from dropdown, Unfold supports several other types of actions. Following table gives overview of all available actions together with their recommended usage:

| **Type** | **Appearance** | **Usage** |
| --- | --- | --- |
| Global | Changelist - top | General actions for all instances in listing |
| Row | Changelist - each row | Action for one specific instance, executable from listing |
| Detail | Changeform - top | Action for one specific instance, executable from detail |
| Submit line | Changeform - submit line | Action performed during form submit (instance save) |

# **For global, row and detail action**

All these actions are based on custom URLs generated for each of them. Handler function for these views is basically function based view.

For actions without intermediate steps, you can write all the logic inside handler directly. Request and object ID are both passed to these action handler functions, so you are free to fetch the instance from database and perform any operations with it. In the end, it is recommended to return redirect back to either detail or listing based on where the action was triggered from.

For actions with intermediate steps, it is recommended to use handler function only to redirect to custom URL with custom view. This view can be extended from base Unfold view, to have unified experience.

# **Changelist actions**

Changelist actions appear as buttons at the top of the changelist page, providing quick access to model-wide operations. Unlike standard Django actions that appear in the default actions dropdown, these actions are displayed as standalone buttons. It's important to note that changelist actions do not receive a queryset or object IDs as parameters, as they are designed for performing general operations on the model level rather than on specific selected objects. This makes them ideal for tasks like bulk imports, exports, or other model-wide administrative functions.

![Changelist actions](https://unfoldadmin.com/static/docs/actions/changelist-actions.webp)

```
# admin.pyfrom django.contrib.admin import registerfrom django.contrib.auth.models import Userfrom django.shortcuts import redirectfrom django.urls import reverse_lazyfrom django.utils.translation import gettext_lazy as _from django.http import HttpRequestfrom unfold.admin import ModelAdminfrom unfold.decorators import action@register(User)class UserAdmin(ModelAdmin):    actions_list = ["changelist_action"]    @action(description=_("Changelist action"), url_path="changelist-action", permissions=["changelist_action"])    def changelist_action(self, request: HttpRequest):        return redirect(          reverse_lazy("admin:users_user_changelist")        )    def has_changelist_action_permission(self, request: HttpRequest):        # Write your own bussiness logic. Code below will always display an action.        return True
```

# **Changelist row actions**

Row actions appear on each individual row in the changelist page as a dropdown button that contains all custom actions defined for that row. These actions provide quick access to row-specific operations directly from the list view. When implementing permissions for row actions, note that the permission callback for **`actions_row`** does not accept an **`object_id`** parameter. This means that permissions can only be set globally for all rows - it is not possible to implement row-specific permission logic that varies based on the individual object being acted upon.

![Changelist row actions](https://unfoldadmin.com/static/docs/actions/changelist-row-actions.webp)

```
# admin.pyfrom django.contrib.admin import registerfrom django.contrib.auth.models import Userfrom django.shortcuts import redirectfrom django.urls import reverse_lazyfrom django.utils.translation import gettext_lazy as _from django.http import HttpRequestfrom unfold.admin import ModelAdminfrom unfold.decorators import action@register(User)class UserAdmin(ModelAdmin):    actions_row = ["changelist_row_action"]    @action(        description=_("Changelist row action"),        permissions=["changelist_row_action"],        url_path="changelist-row-action",        attrs={"target": "_blank"}    )    def changelist_row_action(self, request: HttpRequest, object_id: int):        return redirect(          reverse_lazy("admin:users_user_changelist")        )    def has_changelist_row_action_permission(self, request: HttpRequest):        # Write your own bussiness logic. Code below will always display an action.        return True
```

# **Changeform actions**

Changeform actions appear as buttons at the top of the detail/change form page for individual objects. These actions provide quick access to object-specific operations directly from the detail view. Unlike changelist actions, changeform actions receive the **`object_id`** parameter, allowing you to perform operations on the specific object being viewed.

![Changeform actions](https://unfoldadmin.com/static/docs/actions/changeform-actions.webp)

When implementing permissions for changeform actions, you can use the **`has_[action_name]_permission`** method which receives both the **`request`** and **`object_id`** parameters. This allows you to implement object-specific permission logic that can vary based on the individual object's properties or state.

The actions are defined using the **`actions_detail`** attribute in your ModelAdmin class. Each action can be customized with various parameters like description, URL path, HTML attributes, and permission requirements using the **`@action`** decorator.

You can also organize multiple changeform actions into dropdown menus for a cleaner interface, similar to changelist actions. The dropdown functionality allows you to group related actions together under a single menu button.

```
# admin.pyfrom django.contrib.admin import registerfrom django.contrib.auth.models import Userfrom django.shortcuts import redirectfrom django.urls import reverse_lazyfrom django.utils.translation import gettext_lazy as _from django.http import HttpRequestfrom unfold.admin import ModelAdminfrom unfold.decorators import action@register(User)class UserAdmin(ModelAdmin):    actions_detail = ["changeform_action"]    @action(        description=_("Changeform action"),        url_path="changeform-action",        attrs={"target": "_blank"},        permissions=["changeform_action"]    )    def changeform_action(self, request: HttpRequest, object_id: int):        user = User.objects.get(pk=object_id)        user.block()        return redirect(            reverse_lazy("admin:users_user_change", args=(object_id,))        )    def has_changeform_action_permission(self, request: HttpRequest, object_id: Union[str, int]):        pass
```

# **Changeform submitline actions**

![Changeform submitline actions](https://unfoldadmin.com/static/docs/actions/changeform-submitline-actions.webp)

Changeform submitline actions operate differently from other custom actions in Unfold. When triggered, these actions first save the form data (equivalent to clicking the 'Save' button) before executing any additional logic. This means that by the time your custom action code runs, you'll be working with an already saved instance of the model. This workflow ensures data consistency by guaranteeing that all form changes are properly saved before any custom operations are performed.

```
# admin.pyfrom django.contrib.admin import registerfrom django.contrib.auth.models import Userfrom django.utils.translation import gettext_lazy as _from django.http import HttpRequestfrom unfold.admin import ModelAdminfrom unfold.decorators import action@register(User)class UserAdmin(ModelAdmin):    actions_submit_line = ["changeform_submitline_action"]    @action(        description=_("Changeform submitline action"),        permissions=["changeform_submitline_action"]    )    def changeform_submitline_action(self, request: HttpRequest, obj: User):        """        If instance is modified in any way, it also needs to be saved, since this handler is invoked after instance is saved.        """        obj.is_active = True        obj.save()    def has_changeform_submitline_action_permission(self, request: HttpRequest, object_id: Union[str, int]):        # Write your own bussiness logic. Code below will always display an action.        return True
```

# **Dropdown actions**

Django Unfold provides built-in support for organizing actions into dropdown menus, offering a clean and efficient way to handle multiple actions in your admin interface. This feature is particularly valuable when you need to manage numerous actions while maintaining a tidy and organized user interface. The dropdown functionality is available out of the box for both **`actions_list`** and **`actions_detail`** actions, allowing you to group related actions together in an intuitive menu structure. However, please note that this dropdown functionality is not currently supported for **`actions_submit_line`** and **`actions_row`** actions.

![Dropdown actions](https://unfoldadmin.com/static/docs/actions/dropdown-actions.webp)

To implement a dropdown menu, you'll need to provide a dictionary containing two required keys: **`title`** and **`items`**. The **`title`** key defines the text that will appear as the dropdown button label, while the **`items`** key accepts a list of action names that will be displayed as menu options when the dropdown is expanded. For additional customization, you can include an optional **`icon`** key to display an icon alongside the dropdown title, enhancing the visual appeal and usability of your interface.

```
# admin.pyfrom django.contrib.auth.models import Userfrom unfold.admin import ModelAdmin@register(User)class UserAdmin(ModelAdmin):    actions_list = ["action1", "action2", {        "title": "Dropdown action",        "icon": "person",  # Optional, will display icon in the dropdown title        "items": [            "action3", "action4",        ]    }]
```

# **Action with form example**

This example demonstrates how to create an action that displays a custom form when triggered from the detail object page. When a user clicks the action button, they will be presented with a form interface where they can input additional data needed for the action. This pattern is particularly useful when you need to collect extra information before executing the action's main functionality.

```
# admin.pyfrom django import formsfrom django.contrib.auth.models import Userfrom django.http import HttpRequestfrom django.shortcuts import renderfrom django.urls import reverse_lazyfrom django.utils.translation import gettext_lazy as _from unfold.admin import ModelAdminfrom unfold.decorators import actionfrom unfold.widgets import UnfoldAdminTextInputWidget, UnfoldAdminSplitDateTimeWidgetclass SomeForm(forms.Form):    # It is important to set a widget coming from Unfold    date_start = forms.SplitDateTimeField(label=_("Start"), widget=UnfoldAdminSplitDateTimeWidget)    date_end = forms.SplitDateTimeField(label=_("End"), widget=UnfoldAdminSplitDateTimeWidget)    note = forms.CharField(label=_("Note"), widget=UnfoldAdminTextInputWidget)    # Loads date widget required JS files    class Media:        js = [            "admin/js/vendor/jquery/jquery.js",            "admin/js/jquery.init.js",            "admin/js/calendar.js",            "admin/js/admin/DateTimeShortcuts.js",            "admin/js/core.js",        ]@register(User)class UserAdmin(ModelAdmin):    actions_detail = ["change_detail_action"]    @action(description=_("Change detail action"), url_path="change-detail-action")    def change_detail_action(self, request: HttpRequest, object_id: int) -> str:        # Check if object already exists, otherwise returs 404        obj = get_object_or_404(User, pk=object_id)        form = SomeForm(request.POST or None)        if request.method == "POST" and form.is_valid():            # Process form data            # form.cleaned_data["note"]            # form.cleaned_data["date_from"]            # form.cleaned_data["date_to"]            messages.success(request, _("Change detail action has been successful."))            return redirect(                reverse_lazy("admin:app_model_change", args=[object_id])            )        return render(            request,            "some/action.html",            {                "form": form,                "object": obj,                "title": _("Change detail action for {}").format(obj),                **self.admin_site.each_context(request),            },        )
```

Template displaying the form. Please note that breadcrumbs are empty in this case but if you want, you can configure your own breadcrumbs path.

```
{% extends "admin/base_site.html" %}{% load i18n unfold %}{% block breadcrumbs %}{% endblock %}{% block extrahead %}    {{ block.super }}    <script src="{% url 'admin:jsi18n' %}"></script>    {{ form.media }}{% endblock %}{% block content %}    <form action="" method="post" novalidate>        <div class="aligned border border-base-200 mb-8 rounded-default pt-3 px-3 shadow-sm dark:border-base-800">            {% csrf_token %}            {% for field in form %}                {% include "unfold/helpers/field.html" with field=field %}            {% endfor %}        </div>        <div class="flex justify-end">            {% component "unfold/components/button.html" with submit=1 %}                {% trans "Submit form" %}            {% endcomponent %}        </div>    </form>{% endblock %}
```

# Tabs

# **Changelist tabs**

Django Unfold provides powerful tab navigation capabilities for changelist views, allowing you to create an organized and intuitive interface. You can enhance your admin interface by adding multiple tabs that can link to various registered admin models or custom views. The tab navigation system is highly configurable and can be customized to match your specific administrative needs. All configuration settings are managed through the **`UNFOLD`** dictionary under **`TABS`** key in your project's **`settings.py`** file, making it easy to maintain and update your tab structure as your application evolves.

![Changelist Tabs](https://unfoldadmin.com/static/docs/tabs/changelist-tabs.webp)

```
# settings.pyfrom django.urls import reverse_lazyfrom django.utils.translation import gettext_lazy as _UNFOLD = {    "TABS": [        {            # Which models are going to display tab navigation            "models": [                "app_label.model_name_in_lowercase",            ],            # List of tab items            "items": [                {                    "title": _("Your custom title"),                    "link": reverse_lazy("admin:app_label_model_name_changelist"),                    "permission": "sample_app.permission_callback",                },                {                    "title": _("Another custom title"),                    "link": reverse_lazy("admin:app_label_another_model_name_changelist"),                    "permission": "sample_app.permission_callback",                },            ],        },    ],}# Permission callback for tab itemdef permission_callback(request):    return request.user.has_perm("sample_app.change_model")
```

# **Changeform tabs**

Django Unfold provides the ability to enhance your changeform views with custom tab navigation. This powerful feature allows you to create an organized and intuitive interface by adding multiple tabs that can link to various registered admin models or custom views. The tab navigation system is highly configurable and can be customized to match your specific administrative needs. All configuration settings are managed through the **`UNFOLD`** dictionary under **`TABS`** key in your project's **`settings.py`** file, making it easy to maintain and update your tab structure as your application evolves.

![Changeform Tabs](https://unfoldadmin.com/static/docs/tabs/changeform-tabs.webp)

The changeform tab navigation uses the same configuration structure as changelist tabs, with one key difference: in the **`models`** section, each model must be specified as a dictionary with **`detail`** set to **`True`** to enable tabs on the changeform view.

```
# settings.pyfrom django.urls import reverse_lazyfrom django.utils.translation import gettext_lazy as _UNFOLD = {    "TABS": [        {            # Which changeform models are going to display tab navigation            "models": [                {                    "name": "app_label.model_name_in_lowercase",                    "detail": True, # Displays tab navigation on changeform page                },            ],            # List of tab items            "items": [                {                    "title": _("Your custom title"),                    "link": reverse_lazy("admin:app_label_model_name_changelist"),                    "permission": "sample_app.permission_callback",                },                {                    "title": _("Another custom title"),                    "link": reverse_lazy("admin:app_label_another_model_name_changelist"),                    "permission": "sample_app.permission_callback",                },            ],        },    ],}# Permission callback for tab itemdef permission_callback(request):    return request.user.has_perm("sample_app.change_model")
```

# **Fieldsets tabs**

When the change form contains a lot of fieldsets, sometimes it is better to group them into tabs so it will not be needed to scroll. To mark a fieldset for tab navigation it is required to add a **`tab`** CSS class to the fieldset. Once the fieldset contains **`tab`** class it will be recognized in a template and grouped into tab navigation. Each tab must contain its name. If the name is not available, it will be not included in the tab navigation.

![Fieldsets Tabs](https://unfoldadmin.com/static/docs/tabs/fieldsets-tabs.webp)

```
# admin.pyfrom django.contrib import adminfrom django.utils.translation import gettext_lazy as _from unfold.admin import ModelAdminfrom .models import MyModel@admin.register(MyModel)class MyModelAdmin(ModelAdmin):    fieldsets = (        (            None,            {                "fields": [                    "field_1",                    "field_2",                ],            },        ),        (            _("Tab 1"),            {                "classes": ["tab"],                "fields": [                    "field_3",                    "field_4",                ],            },        ),        (            _("Tab 2"),            {                "classes": ["tab"],                "fields": [                    "field_5",                    "field_6",                ],            },        ),    )
```

**Note:** These tabs are not displayed at the top of the page as other tabs. They are shown in the main content area as one fieldset with smaller tab navigation.

# **Dynamic tabs**

Unfold provides a way to dynamically generate tab navigation. It is possible to use your own logic to generate tab navigation. The tab navigation configuration can be defined as importable string which will call a function with **`HttpRequest`** object as an argument. In this function it is possible to build own tabs navigation structure.

![Dynamic Tabs](https://unfoldadmin.com/static/docs/tabs/dynamic-tabs.webp)

```
# settings.pyUNFOLD = {    "TABS": "your_project.admin.tabs_callback"}
```

Below is an example of how to build own tabs navigation structure in tabs callback function. Based on the request object it is possible to write own logic for the tab navigation structure.

```
# admin.pyfrom django.http import HttpRequestdef tabs_callback(request: HttpRequest) -> list[dict[str, Any]]:    return [        {            # Unique tab identifier to render tabs in custom templates            "page": "custom_page",            # Applies for the changeform view            "models": [                {                    "name": "app_label.model_name_in_lowercase",                    "detail": True                },            ],            "items": [                {                    "title": _("Your custom title"),                    "link": reverse_lazy("admin:app_label_model_name_changelist"),                    "active": True # Configure active tab                    # "active": lambda request: True                },                {                    "title": _("Inline tab"),                    "link": reverse_lazy("admin:app_label_model_name_changelist"),                    "inline": "corresponding-fragment-url"                },            ],        },    ],
```

**Note:** For rendering tabs associated with inlines, you should use the **`inline`** parameter and set its value to the corresponding inline fragment URL. This ensures that the tab correctly links to and displays the inline content when clicked. The inline fragment URL typically corresponds to the slugified verbose name of the inline model.

# **Rendering tabs in custom templates**

Unfold provides a **`tab_list`** template tag which can be used to render tabs in custom templates. The only required argument is the **`page`** name which is defined in **`TABS`** structure on particular tab navigation. Configure **`page`** key to something unique and then use **`tab_list`** template tag in your custom template where the first parameter is the unique **`page`** name.

```
# settings.pyfrom django.http import HttpRequestUNFOLD = {    "TABS": [        {            "page": "custom_page", # Unique tab identifier            "items": [                {                    "title": _("Your custom title"),                    "link": reverse_lazy("admin:app_label_model_name_changelist"),                },            ],        }    ]}
```

Below is an example of how to render tabs in custom templates. It is important to load **`unfold`** template tags before using **`tab_list`** template tag.

```
{% extends "admin/base_site.html" %}{% load unfold %}{% block content %}    {% tab_list "custom_page" %}{% endblock %}
```

**Note:** When it comes which tab item is active on custom page, it is not up to Unfold to find out a way how to mark links as active. The tab configuration provides **`is_active`** key which you can use to set active tab item.

# Widgets

# **Unfold widget ArrayWidget**

```
# settings.pyINSTALLED_APPS = [    "unfold",    "unfold.contrib.forms",]
```

The example below demonstrates how to implement ArrayWidget in your Django admin class. By using the **`formfield_overrides`** setting, you can configure all **`ArrayField`** fields to utilize the **`ArrayWidget`** for rendering input fields. The widget provides flexibility in how the data is displayed - when **`choices`** are specified, it automatically switches from a standard text input to a dropdown list interface, allowing users to select from predefined options. This makes it particularly useful for managing array data that should be constrained to a specific set of values.

![Array widget](https://unfoldadmin.com/static/docs/widgets/array.webp)

When implementing the ArrayWidget with choices, it's important to note that the widget itself doesn't automatically inherit or detect any choice options from the field definition. This means you'll need to explicitly provide the choices when initializing the widget. The recommended approach is to override the **`get_form`** method in your ModelAdmin class, where you can initialize the widget with the desired **`choices`** parameter. This gives you full control over what options are available in the dropdown list and ensures that the widget properly constrains user input to valid selections. The choices can be defined using Django's TextChoices class or any other compatible choices format.

```
# admin.pyfrom django.contrib import adminfrom django.contrib.postgres.fields import ArrayFieldfrom django.db.models import TextChoicesfrom django.utils.translation import gettext_lazy as _from unfold.admin import ModelAdminfrom unfold.contrib.forms.widgets import ArrayWidgetclass SomeChoices(TextChoices):    OPTION_1 = "OPTION_1", _("Option 1")    OPTION_2 = "OPTION_2", _("Option 2")@admin.register(MyModel)class CustomAdminClass(ModelAdmin):    formfield_overrides = {        ArrayField: {            "widget": ArrayWidget,        }    }    # If you need to provide choices for the widget, you can do it in the get_form method.    def get_form(self, request, obj=None, change=False, **kwargs):        form = super().get_form(request, obj, change, **kwargs)        form.base_fields["array_field"].widget = ArrayWidget(choices=SomeChoices)        return form
```

# **Unfold widget WysiwygWidget**

To enhance your Django admin interface with rich text editing capabilities, you'll need to integrate the WysiwygWidget component. This requires adding **`unfold.contrib.forms`** to your project's **`INSTALLED_APPS`** setting as a mandatory dependency. The WysiwygWidget leverages the powerful [**Trix editor**](https://trix-editor.org/), an elegant open-source rich text editor that provides a clean and intuitive interface for content creation. Trix offers essential formatting options while maintaining simplicity and ease of use, making it an excellent choice for managing text content in your Django admin interface.

![Wysiwyg widget](https://unfoldadmin.com/static/docs/widgets/wysiwyg.webp)

```
# settings.pyINSTALLED_APPS = [    "unfold",    "unfold.contrib.forms",]
```

The following example demonstrates how to enhance all **`TextField`** fields in your admin interface by replacing them with the **`WysiwygWidget`**. This is achieved by using the **`formfield_overrides`** setting in your ModelAdmin class, which automatically applies the rich text editor to every text field. While the **`WysiwygWidget`** currently doesn't include built-in file upload functionality, you can still incorporate images into your content by first uploading them through your regular media management system and then inserting the image URL into the editor. This provides a flexible workflow for managing both text and media content within your admin interface.

```
# admin.pyfrom django.db import modelsfrom unfold.admin import ModelAdminfrom unfold.contrib.forms.widgets import WysiwygWidget@admin.register(MyModel)class CustomAdminClass(ModelAdmin):    formfield_overrides = {        models.TextField: {            "widget": WysiwygWidget,        }    }
```

# Inlines

# **Inlines**

Unfold inlines are built upon Django's inline functionality, providing enhanced styling capabilities and additional configuration options. While Django's native inline classes (**`StackedInline`** and **`TabularInline`**) will function correctly, they won't match Unfold's default design aesthetic. For the best visual consistency and full feature set, it is strongly recommended to use Unfold's own inline classes instead of the standard Django ones.

```
# admin.pyfrom django.contrib import adminfrom django.contrib.auth.models import Userfrom unfold.admin import StackedInline, TabularInlineclass MyStackedInline(StackedInline):    model = Userclass MyTabularInline(TabularInline):    model = User@admin.register(User)class UserAdmin(ModelAdmin):    inlines = [MyStackedInline, MyTabularInline]
```

# **Available options for Unfold inlines**

# **Custom inline title**

By default, each inline row's title is derived from the model's **`__str__`** implementation. However, Unfold provides the ability to customize this title specifically for inlines by implementing a **`get_inline_title`** method on the model. This method can return a custom title that will only be used in inline contexts, allowing for more descriptive and context-specific labels.

```
from django.contrib.auth.models import Userfrom unfold.admin import TabularInlineclass User(models.Model):    # fields, meta ...    def get_inline_title(self):        return "Custom title"class MyInline(TabularInline):    model = User
```

# **Hide title row**

You can hide the title row for both **`StackedInline`** and **`TabularInline`** by setting the **`hide_title`** attribute to **`True`**. This feature is particularly useful when you want to create a more compact and streamlined interface. Please note that for **`StackedInline`**, the delete permission (**`can_delete`**) must be disabled to hide the title row, as the delete checkbox is contained within it.

```
# admin.pyfrom django.contrib.auth.models import Userfrom unfold.admin import TabularInlineclass MyInline(TabularInline):    model = User    hide_title = True
```

# **Collapsible StackedInline**

Unfold enhances the **`StackedInline`** functionality by introducing a collapsible mode. When enabled, this feature allows you to display multiple records in a space-efficient manner by defaulting to a collapsed state. This is particularly useful when dealing with forms that contain numerous inline entries, as it helps maintain a clean and organized interface.

Key features of collapsible StackedInlines: - Records are collapsed by default, saving vertical space - Users can expand individual records as needed - Records containing validation errors automatically expand to highlight the issues - The collapsed state is preserved during form submission - Each record can be independently expanded or collapsed

To implement this feature, simply set the **`collapsible`** attribute to **`True`** in your StackedInline class:

```
from django.contrib.auth.models import Userfrom unfold.admin import StackedInlineclass User(models.Model):    inlines = [SomeInline]class SomeInline(StackedInline):    collapsible = True
```

# **Nonrelated inlines**

Django Unfold provides a powerful feature for displaying inlines that don't have a direct relationship (no foreign key) with the main model in the changeform view. These nonrelated inlines are available through the **`unfold.contrib.inlines`** module. To use this functionality, ensure that you have included the module in your project's **`INSTALLED_APPS`** configuration within settings.py. This feature allows you to display and manage related data even when there isn't a traditional database relationship between the models.

![Nonrelated inlines](https://unfoldadmin.com/static/docs/inlines/nonrelated-inlines.webp)

```
from django.contrib.auth.models import Userfrom unfold.admin import ModelAdminfrom unfold.contrib.inlines.admin import NonrelatedTabularInlinefrom .models import OtherModelclass OtherNonrelatedInline(NonrelatedTabularInline):  # NonrelatedStackedInline is available as well    model = OtherModel    fields = ["field1", "field2"]  # Ignore property to display all fields    def get_form_queryset(self, obj):        """        Gets all nonrelated objects needed for inlines. Method must be implemented.        """        return self.model.objects.all()    def save_new_instance(self, parent, instance):        """        Extra save method which can for example update inline instances based on current        main model object. Method must be implemented.        """        pass@admin.register(User)class UserAdmin(ModelAdmin):    inlines = [OtherNonrelatedInline]
```

# **Sortable inlines**

Django Unfold provides a powerful sorting capability for inlines through the **`ordering_field`** attribute in the inline class. When specified, this field determines the sorting order of inlines within the admin panel. For enhanced UI customization, you can optionally hide the ordering field from the interface by setting **`hide_ordering_field`** to **`True`**.

![Sortable inlines](https://unfoldadmin.com/static/docs/inlines/sortable-inlines.webp)

Important considerations when implementing sortable inlines:

- The model field designated for ordering must be defined as a **`PositiveIntegerField`** with **`db_index=True`** for optimal performance
- Sorting functionality is limited to existing records - newly added inline items must first be saved before they can be sorted
- The sorting feature is specifically designed for inline views and is not available in the changelist view
- The ordering field will automatically handle maintaining the correct sequence of items when records are reordered

```
# admin.pyfrom unfold.admin import TabularInlinefrom .models import User# This works for StackedInline as wellclass MyInline(TabularInline):    model = User    ordering_field = "weight"    hide_ordering_field = True    list_display = ["email", "weight"]  # Weight is mandatory field
```

To enable sorting functionality, create a model field of type **`PositiveIntegerField`** with **`db_index=True`**. This field will be used by the Unfold admin to maintain the sorting order of your records.

```
# models.pyfrom django.db import modelsfrom django.utils.translation import gettext_lazy as _class User(models.Model):    weight = models.PositiveIntegerField(_("weight"), default=0, db_index=True)
```

Pagination on inlines can be enabled by providing the **`per_page`** property in the inline class. This feature is particularly useful when dealing with models that have a large number of related objects, as it helps improve page load times and provides a better user experience by breaking down the data into manageable chunks. The **`per_page`** property accepts an integer value that determines how many inline records will be displayed on each page.

![Paginated inlines](https://unfoldadmin.com/static/docs/inlines/paginated-inlines.webp)

It is possible to define multiple paginated inlines on the same page without any conflicts. This flexibility allows administrators to work with complex models that have multiple relationships, each potentially containing numerous records. Django Unfold handles the pagination state independently for each inline, ensuring that navigating through one inline's pages doesn't affect the pagination state of other inlines on the same admin page.

Each inline has its own unique query parameter in the URL to maintain its pagination state. This implementation ensures that when users navigate between pages of different inlines, the system can track and maintain the current page for each inline separately. The unique query parameters are automatically generated and managed by Django Unfold, so developers don't need to worry about potential conflicts or parameter naming conventions.

AJAX pagination is not currently supported for inlines. This means that when users click on pagination links, the entire admin page will reload to display the new set of records. While this approach may not be as seamless as AJAX-based pagination, it ensures compatibility with Django's existing admin infrastructure and maintains the reliability of the admin interface functionality.

If inline records fit on only one page, no pagination controls will be displayed to keep the interface clean and uncluttered. Django Unfold automatically detects when the total number of records is less than or equal to the specified **`per_page`** value and hides the pagination controls accordingly. This intelligent behavior prevents unnecessary UI elements from appearing when they serve no functional purpose.

```
from unfold.admin import StackedInline, TabularInline, GenericStackedInline, GenericTabularInlinefrom unfold.contrib.inlines.admin import NonrelatedStackedInline, NonrelatedTabularInline############################################# Regular inlines############################################class SomeStackedInline(StackedInline):    model = YourModel    per_page = 10class SomeTabularInline(TabularInline):    model = YourModel    per_page = 10############################################# Generic inlines############################################class SomeGenericStackedInline(GenericStackedInline):    model = YourModel    per_page = 10class SomeGenericTabularInline(GenericTabularInline):    model = YourModel    per_page = 10############################################# Nonrelated inlines############################################class SomeNonrelatedStackedInline(NonrelatedStackedInline):    model = YourModel    per_page = 10class SomeNonrelatedTabularInline(NonrelatedTabularInline):    model = YourModel    per_page = 10
```

# Fields

# **JsonField formatting and syntax highlighting**

Unfold currently provides basic JSON formatting and syntax highlighting, but only when the JSON field is included in the admin configuration's **`readonly_fields`** list. For fields not marked as read-only, Unfold displays them as plain text using the **`UnfoldAdminTextareaWidget`**.

When a JSON field is both marked as read-only and the Pygments library is installed (via **`pip install pygments`**), Unfold will display the field with syntax highlighting and proper formatting. If Pygments is not installed, the field will be displayed without any formatting. Note that the absence of Pygments will not cause any errors in Unfold's functionality.

# **Basic formatting without Pygments**

Even without the Pygments library installed, you can still achieve basic JSON formatting by using the **`PrettyJSONEncoder`** encoder shown in the example below.

```
# encoders.pyimport jsonclass PrettyJSONEncoder(json.JSONEncoder):    def __init__(self, *args, indent, sort_keys, **kwargs):        super().__init__(*args, indent=4, sort_keys=True, **kwargs)
```

After creating the encoder, we can apply it to a field definition in the **`models.py`** file. When a value is saved to the database, this encoder will automatically format the JSON data. As a result, the raw value stored in the database will be properly formatted.

```
# models.pyfrom django.db import modelsfrom django.utils.translation import gettext_lazy as _class CustomModel(models.Model):    data = models.JSONField(_("data"), null=True, blank=True, encoder=PrettyJSONEncoder)
```

Finally, register the model in admin.py and include the JSON field in the **`readonly_fields`** list to ensure it displays with proper formatting.

```
# admin.pyfrom django.contrib import adminfrom unfold.admin import ModelAdmin@admin.register(CustomModel)class CustomAdminClass(ModelAdmin):    readonly_fields = ["data"]
```

# Integrations

# Components

# Decorators

# Styles and Scripts

# **Loading styles and scripts**

Custom styles, such as those needed for a custom dashboard, can be loaded by configuring the **STYLES** key within the **UNFOLD** dictionary in your settings.py file. This key accepts a list of either strings or lambda functions, and the specified files will be loaded across all pages. For JavaScript files, you can use the same approach by utilizing the **SCRIPTS** key.

```
# settings.pyfrom django.templatetags.static import staticUNFOLD = {    "STYLES": [        lambda request: static("css/styles.css"),    ],    "SCRIPTS": [        lambda request: static("js/scripts.js"),    ],}
```

**Note:** When deploying to production, make sure to run the **`python manage.py collectstatic`** command to collect all static files. This ensures that all custom styles and scripts are properly included in the production build.

# **Loading Tailwind stylesheet in Django project**

When creating a custom dashboard or adding custom components, you may need to add your own styles to provide styling for new elements. The way styles can be loaded is described in the previous section. Once the styles are loaded, you can write CSS selectors with properties. This is sufficient if you don't need to use Tailwind.

For Unfold version 0.56 and above, we strongly recommend writing your own custom CSS styles directly rather than attempting to set up and configure Tailwind in your project. This approach is simpler, more maintainable, and helps avoid potential conflicts with Unfold's built-in Tailwind configuration. By writing custom CSS, you maintain full control over your styling while ensuring compatibility with Unfold's existing design system.

# **Tailwind 4.x for Unfold 0.57+**

Tailwind 4 introduces a significant change in how configuration is managed. Unlike previous versions that relied on a separate **`tailwind.config.js`** file, Tailwind 4 consolidates all settings and configurations directly within your main CSS file. This new approach simplifies the setup process and provides a more streamlined development experience.

To get started with Tailwind in your project, you'll need to install both the Tailwind CSS framework and its CLI tool. The CLI tool is essential for compiling your Tailwind styles into production-ready CSS. Install them using npm with the following command:

```
npm i tailwindcss @tailwindcss/cli
```

Create a new **`styles.css`** file in your project directory and add a single import statement at the top. This simplified configuration demonstrates how dramatically Tailwind 4 has evolved compared to the more complex configuration required in Tailwind 3. The new approach requires just one line of code:

```
/* styles.css */@import 'tailwindcss';
```

After setting up your configuration, compile the styles using the CLI tool. The resulting CSS file can then be added to your **`UNFOLD["STYLES"]`** settings to apply your custom Tailwind styles across the admin interface.

```
npx @tailwindcss/cli -i styles.css -o your_project/static/css/styles.css --minify
```

```
# settings.pyfrom django.templatetags.static import staticUNFOLD = {    "STYLES": [        lambda request: static("css/styles.css"),    ],}
```

# **Tailwind 3.x for Unfold below 0.56**

Before starting with the Tailwind configuration at the project level, you need to install Tailwind CSS into your project by running **`npm install tailwindcss`** in the project directory. Don't forget to add **`package.json`** and **`package-lock.json`** to your repository.

Most likely, you'll want new elements to match the rest of the administration panel. First, create a **`tailwind.config.js`** file in your application. Below is the minimal configuration that contains color specifications so all Tailwind classes like **`bg-primary-600`** will match the admin theme.

```
// tailwind.config.jsmodule.exports = {  // Support dark mode classes  darkMode: "class",  // Your project's files to scan for Tailwind classes  content: ["./your_project/**/*.{html,py,js}"],  theme: {    extend: {      // Colors that match with UNFOLD["COLORS"] settings      colors: {        base: {          50: "rgb(var(--color-base-50) / <alpha-value>)",          100: "rgb(var(--color-base-100) / <alpha-value>)",          200: "rgb(var(--color-base-200) / <alpha-value>)",          300: "rgb(var(--color-base-300) / <alpha-value>)",          400: "rgb(var(--color-base-400) / <alpha-value>)",          500: "rgb(var(--color-base-500) / <alpha-value>)",          600: "rgb(var(--color-base-600) / <alpha-value>)",          700: "rgb(var(--color-base-700) / <alpha-value>)",          800: "rgb(var(--color-base-800) / <alpha-value>)",          900: "rgb(var(--color-base-900) / <alpha-value>)",          950: "rgb(var(--color-base-950) / <alpha-value>)",        },        primary: {          50: "rgb(var(--color-primary-50) / <alpha-value>)",          100: "rgb(var(--color-primary-100) / <alpha-value>)",          200: "rgb(var(--color-primary-200) / <alpha-value>)",          300: "rgb(var(--color-primary-300) / <alpha-value>)",          400: "rgb(var(--color-primary-400) / <alpha-value>)",          500: "rgb(var(--color-primary-500) / <alpha-value>)",          600: "rgb(var(--color-primary-600) / <alpha-value>)",          700: "rgb(var(--color-primary-700) / <alpha-value>)",          800: "rgb(var(--color-primary-800) / <alpha-value>)",          900: "rgb(var(--color-primary-900) / <alpha-value>)",          950: "rgb(var(--color-primary-950) / <alpha-value>)",        },        font: {          "subtle-light": "rgb(var(--color-font-subtle-light) / <alpha-value>)",          "subtle-dark": "rgb(var(--color-font-subtle-dark) / <alpha-value>)",          "default-light": "rgb(var(--color-font-default-light) / <alpha-value>)",          "default-dark": "rgb(var(--color-font-default-dark) / <alpha-value>)",          "important-light": "rgb(var(--color-font-important-light) / <alpha-value>)",          "important-dark": "rgb(var(--color-font-important-dark) / <alpha-value>)",        }      }    }  }};
```

Next, create a **`styles.css`** file in your project's root directory. This file will be used to compile Tailwind CSS into your project:

```
/* styles.css */@tailwind base;@tailwind components;@tailwind utilities;/* Your custom styles */.some-class {    @apply bg-primary-600;}
```

Once the configuration file is set up, you can compile the styles which can be loaded into the admin using the **STYLES** key in the **UNFOLD** dictionary.

```
# One-time build with minified outputnpx tailwindcss -i styles.css -o your_project/static/css/styles.css --minify# Watch for changes and compile automatically with minified outputnpx tailwindcss -i styles.css -o your_project/static/css/styles.css --minify --watch
```

You can automate this process by adding the following scripts to your **`package.json`** file:

```json
{
  "scripts": {
    "tailwind:watch": "npx tailwindcss -i styles.css -o your_project/static/css/styles.css --minify --watch",
    "tailwind:build": "npx tailwindcss -i styles.css -o your_project/static/css/styles.css --minify"
  }
  // rest of configuration
}
```

# Development